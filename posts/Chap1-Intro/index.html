<!DOCTYPE html><html lang="ko" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Docker 소개" /><meta name="author" content="Banjung" /><meta property="og:locale" content="ko" /><meta name="description" content="Summary Docker 컨테이너 기반의 오픈 소스 가상화 플랫폼이다." /><meta property="og:description" content="Summary Docker 컨테이너 기반의 오픈 소스 가상화 플랫폼이다." /><link rel="canonical" href="https://hongwoojeon.github.io/posts/Chap1-Intro/" /><meta property="og:url" content="https://hongwoojeon.github.io/posts/Chap1-Intro/" /><meta property="og:site_name" content="Banjung`s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-05T11:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Docker 소개" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@Banjung" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Banjung"},"dateModified":"2022-04-08T09:55:50+09:00","datePublished":"2022-04-05T11:00:00+09:00","description":"Summary Docker 컨테이너 기반의 오픈 소스 가상화 플랫폼이다.","headline":"Docker 소개","mainEntityOfPage":{"@type":"WebPage","@id":"https://hongwoojeon.github.io/posts/Chap1-Intro/"},"url":"https://hongwoojeon.github.io/posts/Chap1-Intro/"}</script><title>1. Docker 소개 | Banjung`s Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Banjung`s Blog"><meta name="application-name" content="Banjung`s Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/favicons/android-chrome-192x192.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Banjung`s Blog</a></div><div class="site-subtitle font-italic">Banjung`s Blog</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/hongwoojeon" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['ghddnek1','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>1. Docker 소개</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>1. Docker 소개</h1><div class="post-meta text-muted"><div> By <em> Banjung </em></div><div class="d-flex"><div> <span> Posted <em class="timeago" data-ts="1649124000" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-05 </em> </span> <span> Updated <em class="timeago" data-ts="1649379350" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-04-08 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4618 words"> <em>25 min</em> read</span></div></div></div><div class="post-content"><h2 id="summary"><span class="mr-2">Summary</span><a href="#summary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h4 id="docker"><span class="mr-2">Docker</span><a href="#docker" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>컨테이너 기반의 오픈 소스 가상화 플랫폼이다.</ul><h4 id="이미지"><span class="mr-2">이미지</span><a href="#이미지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>컨테이너 실행에 필요한 파일과 설정값 등을 포함한다.<li>상태값을 가지지 않고 변하지 않는다.(Immutable)</ul><h4 id="컨테이너"><span class="mr-2">컨테이너</span><a href="#컨테이너" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>OS를 가상화해 여러 개의 고립된 리눅스 시스템을 실행하는 방법이다.</ul><h4 id="기능"><span class="mr-2">기능</span><a href="#기능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Build: Docker 이미지를 만드는 기능<li>Ship : Docker 이미지를 공유하는 기능<li>Run : Docker 컨테이너를 작동시키는 기능</ul><h2 id="docker란"><span class="mr-2">Docker란?</span><a href="#docker란" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>컨테이너를 사용해서 응용 프로그램을 개발, 배포 및 실행하기 위한 오픈소스 가상화 플랫폼이다.</ul><h4 id="docker-platform-engine"><span class="mr-2">Docker Platform, Engine</span><a href="#docker-platform-engine" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>컨테이너 기술을 사용하여 애플리케이션의 실행 환경을 구축 및 운용하기 윈한 플랫폼<li>애플리케이션의 실행에 필요한 환경을 하나의 이미지로 모아 관리함으로 이식성을 높힌다.<li>격리와 보안이 된 OS에 많은 컨테이너를 적재하여 동시에 실행할 수 있다.<li>VM의 경우 각기 다른 OS를 동시에 구동할 수 있는 반면 컨테이너 환경은 컨테이너 가상화 보다 훨씬 가벼운 기술이다.<li>Docker Engine은 데몬 프로세스라고 부르는 장기 실행 프로그램의 일정인 서버와 데몬이 통신할 수 있도록 인터페이스를 제공하는 REST API, CLI로 구성된다.<li>CLI는 <a href="https://docs.docker.com/engine/reference/commandline/dockerd/">Dockered</a> 커맨드로 수행되는 데몬 프로세스는 이미지, 컨테이너, 네트워크, 볼륨 등의 Docker 객체들을 생성하고 관리한다.</ul><h2 id="docker-사용의-이점"><span class="mr-2">Docker 사용의 이점</span><a href="#docker-사용의-이점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>빠르고 일관된 애플리케이션 제공<ul><li>애플리케이션과 서비스를 제공하는 로컬 컨테이너를 사용하여 표준화 된 환경에서 작업 할 수 있도록 한다.(개발 수명주기 간소화)<li>컨테이너는 지속적 통합 및 지속적 배포(CI / CD) workflow에 적합하다.</ul><li>반응형 배포 및 확장<ul><li>개발자의 로컬 PC, 가상 머신, 클라우드 등 혼합 환경에서 실핼할 수 있다.</ul><li>동일한 하드웨어에서 더 많은 Workload 실행<ul><li>가볍고 빠르다.<li>Hypervisor 기반 가상 머신에 대한 실행이 가능하고 비용이 효율적이다.<li>적은 리소스로 많은 작업을 수행해야 하는 고밀도 환경과 중소 규모 배포에 적합하다.</ul></ul><h2 id="docker의-배경"><span class="mr-2">Docker의 배경</span><a href="#docker의-배경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h4 id="monolithic-에서-microservie로-architecture-변경"><span class="mr-2">Monolithic 에서 Microservie로 Architecture 변경</span><a href="#monolithic-에서-microservie로-architecture-변경" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Monolithic Architecture<ul><li>기존의 전통적인 웹 시스템 개발 스타일로 하나의 애플리케이션 내에 모든 로직이 들어가 있는 <code class="language-plaintext highlighter-rouge">통짜 구조</code> 이다.</ul><li>Microservice Architecture<ul><li>소프트웨어가 잘 정의된 API를 통해 통신하는 소규모의 독립적인 서비스로 구성되어 있는 경우의 소프트웨어 개발을 위한 아키텍처 및 조직적 접근 방식이다.</ul><li>대형 Apllication들은 다양한 기기와 환경들에 맞춰 빠르게 지원하기 위해 잘게 쪼개졌으며, 개발자들은 최상의 성능을 위해서 사용 가능한 Service들을 <strong>개별적으로 조립하여 제공</strong> 하였다.</ul><h2 id="가상머신의-등장"><span class="mr-2">가상머신의 등장</span><a href="#가상머신의-등장" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>컴퓨터 안에서 컴퓨터를 만들어내기 위한 시도이다.<li>컴퓨터 성능이 급격히 좋아지면서 PC에서도 흔히 사용한다.<li>서버 성능이 너무 좋아져 대부분 시간을 서버가 놀고있는 문제가 발생한다.<li>서버에 가상머신을 여러개 띄워서 동일시간 작업량을 늘린다.<h4 id="가상화"><span class="mr-2">가상화</span><a href="#가상화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><li>흔히 알고있는 가상화(Virtualization)는 VMWare Workstation과 같은 소프트웨어를 이용해, Linux나 MacOS위에 Windows를 올려서 사용하는 그런 것을 떠올릴 수 있다. 이런 방식들이 하드웨어와 소프트웨어를 결합하여 가상 머신(VM)을 만들어 사용하는, Platform 가상화를 의미한다.<li>Platform 가상화는 주어진 하드웨어 Platform 위에서 제어 프로그램, 즉 Host 소프트웨어를 통해 실행된다. Host 소프트웨어는 Host 환경 내의 Guest 소프트웨어에 맞춰 가상 머신(VM)을 만들어낸다. Guest 소프트웨어는 완전한 운영체제이며, 독립된 하드웨어 Platform에 설치된 것처럼 실행된다.<h4 id="가상화-작동원리"><span class="mr-2">가상화 작동원리</span><a href="#가상화-작동원리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><li>물리저 서버 하드웨어에 운영 체제를 직접 설치하는 대신 하이퍼바이저 소프트웨어를 설치하여 하나의 물리적 시스템을 가상 머신이라는 분리된 여러 가상 환경으로 분할하는 방식으로 구현된다.<h4 id="가상화의-장점"><span class="mr-2">가상화의 장점</span><a href="#가상화의-장점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4></ul><div class="table-wrapper"><table><thead><tr><th>성질<th>내용<tbody><tr><td>유연성<td>동일한 하드웨어에서 여러 운영 체제를 동시에 실행할 수 있다.<tr><td>민첩성<td>한 물리적 서버에서 다른 물리적 서버로 파일이나 사진을 이동하는 것처럼 운영 체제 이동이 가능하다.<tr><td>내결함성<td>물리적 서버에 장애가 발생하면 관리 소프트웨어는 이용 가능한 다른 서버로 신속하게 Instance를 Migration 하여 물리적 하드웨어에 장애가 발생했다는 것조차 알 수 없도록 조치합니다.<tr><td>비용 효율성<td>필요한 물리적 서버 수를 줄일 수 있고 전기 요금과 운영 및 유지보수 비용도 절감할 수 있습니다.</table></div><h4 id="hypervisor-가상화-vs-container-가상화"><span class="mr-2">Hypervisor 가상화 vs Container 가상화</span><a href="#hypervisor-가상화-vs-container-가상화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><div class="table-wrapper"><table><thead><tr><th>Virtual Machine(KVM. Xen)<th>Container(LXC, Docker)<tbody><tr><td>하이퍼바이저를 통한 컴퓨팅 가상화로 Guest OS를 동작시킨다.<td>OS를 가상화해 여러 개의 고립된 리눅스 시스템을 동작시킨다.</table></div><ul><li>Container 가상화는 호스트 OS에서 논리적으로 구역을 만들어 어플리케이션과 어플리케이션에 필요한 라이브러리를 집어넣고, 독립적인 어플리케이션이 동작하는 서버처럼 만드는 가상화 기법이다.<li>Container 가상화는 가상 머신의 OS가 필요하지 않기 때문에 필요한 리소스가 호스트 가상화나 하이퍼바이저 가상화보다 매우적다.<li>Container 가상화는 가볍로 빠르며 가상의 OS가 없기 때문에 Overhead가 적다는 특징이 있다.<li>Hyperviser 기반의 가상시스템에서 어플리케이션을 구동하려면 실제 구동되기 까지의 시간이 길게 걸리지만, <strong>Container는 이미 시스템이 동작되고 있는 상태에서 어플리케이션 부분만 가상화 되어 실행되기 때문에 속도가 훨씬 빠르다.</strong></ul><h4 id="전가상화vm-vs-반가상화container"><span class="mr-2">전가상화(VM) vs 반가상화(Container)</span><a href="#전가상화vm-vs-반가상화container" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>이미지 추가</ul><h2 id="리눅스-컨테이터lxc"><span class="mr-2">리눅스 컨테이터(LXC)</span><a href="#리눅스-컨테이터lxc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>전가상화든 반가상화든 추가적인 OS를 설치하여 가상화하는 방법은 성믄문제가 있었고 이를 개선하기위해 프로세스를 격리하는 방식이 등장한다.<li>리눅스에서는 이 방식을 리눅스 컨테이너라고 하고 단순히 프로세스를 격리시키기 때문에 가볍고 빠르게 동작한다.<li>CPU나 메모리는 딱 프로세스가 필요한 만큼만 추가로 사용하고 성능적으로도 거의 손실이 없다.<li>리눅스 커널의 namespaces, cgroups</ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>namespaces

Docker는 컨테이너라는 독립된 환경을 만들고 이 환경에서 어플리케이션을 실행한다. namespace는 독립된 환경을 만들 때 사용하는 기능 중 하나이다.
namespace를 번역하면 '이름공간'이다. Docker가 독립된 환경을 만들 때 namespace 기능을 사용하여 각 환경에 이름을 부여하고 쉽게 참조 될 수 있도록한다.
namespace를 사용하여 다음의 독립된 환경을 구축할 수 있다.

cgroup
Docker는 호스트의 리소스를 공유하여 사용한다. 이 때 사용되는 기능이 cgroup이다.
cgroup은 프로세스 또는 쓰레드(thread)를 그룹화하여 관리하는 기능이다. 이를 통해 호스트의 CPU나 메모리를 그룹별로 제한할 수 있다.
또한 같은 호스트에서 동작하는 서로 다른 컨테이너에 영향을 주지 않도록 막아주는 역할도 한다.
</pre></table></code></div></div><ul><li>가상화가 아닌 격리 개념이다.</ul><h2 id="container의-한계"><span class="mr-2">Container의 한계</span><a href="#container의-한계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>기존 Hypervisor 기반의 가상화 기술보다 Container가 뛰어난 부분은 앞서 얘기한 것처럼 속도가 빠르고 자원 소비율이 적기 때문에, 같은 자원을 갖고 있는 Host 시스템에서 더 많은 Application을 가상화 기반 위에 동작시킬 수 있다는 점이다.<li>하지만 Docker의 기반이 되는 Container기술은 Application의 구동 환경을 가상화하기 때문에, 호스트 시스템에서 제공하는 운영체제와 같은 환경에서만 제공한다는 단점이 있다.<li>즉, 일반 Docker 환경(Linux)에서 Windows Application 실행은 현재로선 어렵다는 것이다.<li>이는 Container 기술 자체가 운영체제와 실행 바이너리, 라이브러리를 공유하면서 Application 자체의 실행 환경만 가상화하여 제공하는 기술이기 때문에 어쩔 수 없는 상황이다.</ul><h2 id="docker의-특징"><span class="mr-2">Docker의 특징</span><a href="#docker의-특징" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>게스트 OS를 설치하지 않는다.<ul><li>이미지에 서버 운영을 위한 프로그램과 라이브러리만 격리해서 설치한다.<li>이미지 용량이 크게 줄어들었다.</ul><li>하드웨어 가상화 계층이 없다.<ul><li>메모리 접근, 파일 시스템, 네트워크 전송 속도가 가상머신에 비해 월등히 빠르다.</ul><li>환경에 구애받지 않고 Application을 신속하게 배포 및 확장할 수 있는 환경을 제공해준다.<li>이미지 버전관리도 제공하고 중앙 저장소에 이미지를 올리고 받을 수 있다.<li>GitHub와 비슷한 형태의 Docker Hub(repository)에서 도커 이미지가 공유 가능하다.<li>다양한 API를 제공하여 원하는 만큼 자동화가 가능하다.<h4 id="docker를-사용하는-이유"><span class="mr-2">Docker를 사용하는 이유?</span><a href="#docker를-사용하는-이유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><li>Docker는 Application 및 Service를 Container를 사용하여 표준화된 환경에서 구동할 수 있도록 한다.<li>개발 주기를 단축시켜 빠르게 배포할 수 있다.<li>Container의 이점은 CI/CD Workflow에서 극대화된다.<li>환경에 따라, 배포와 확장이 자유롭다.<li>Docker는 개발자의 Laptop, Datacenter의 VM, Cloud 환경 또는, 여러 다양한 환경에 쉽게 이식하여 사용할 수 있다.<li>Docker의 이런 특성으로 인해, 비즈니스 요구 사항에 맞춰 Application과 Service를 부하에 따라 동적으로 관리할 수 있으며, 거의 실시간으로 축소 또는 확장할 수 있다.</ul><h2 id="docker의-구성요소"><span class="mr-2">Docker의 구성요소</span><a href="#docker의-구성요소" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h4 id="docker-daemon"><span class="mr-2">Docker Daemon</span><a href="#docker-daemon" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Docker Daemon(dockerd)은 Client로부터 API 요청을 수신하고 Image, Container, Network 및 Volume과 같은 Docker Object를 관리한다.<li>Daemon은 Docker 서비스를 관리하기 위해 다른 Daemon과 통신할 수 있다.<h4 id="docker-client"><span class="mr-2">Docker Client</span><a href="#docker-client" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><li>Docker Client(docker)는 사용자가 Docker Daemon과 통신하는 주요 방법이다.<li>docker run과 같은 명령을 사용하면 Docker Client는 해당 명령을 Docker Daemon으로 전송하여 명령을 수행하게 한다.<li>docker 명령은 Docker API를 사용하며, Docker Client는 둘 이상의 Docker Daemon과 통신 할 수 있다.<h4 id="docker-registry"><span class="mr-2">Docker Registry</span><a href="#docker-registry" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><li>Docker Registry는 Docker Image를 저장한다.<li>Docker Hub는 누구나 사용할 수있는 Public Registry이며, Docker는 기본적으로 Docker Hub에서 Image를 찾아 Container를 구성하도록 되어 있다.<li>예를 들어, docker pull을 사용하여 Image를 Registry에서 Local로 내려받을 수 있으며, docker push를 통해 Local의 Image를 Registry에 저장할 수도 있다.<li>Docker Registry는 개개인이 구성할 수도 있으며, Docker의 Enterprise Edition에서 제공되는 Docker Trusted Registry이 포함된 Docker Datacenter를 사용할 수도 있다.</ul><h2 id="client-server-model"><span class="mr-2">Client-Server Model</span><a href="#client-server-model" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>Docker는 서비스의 요청자(Docker Client) 와 제공자(Docker Server) 간의 작업이 분리되어 동작하는 Client-Server Model로 되어있으며, Docker Client는 REST API를 사용하여 Docker Server를 제어한다.<ul><li>Docker Client: docker CLI<li>Docker Server: docker daemon<li>Docker REST API</ul><li>Docker Server(docker daemon)는 Docker Client로부터 받은 요청에 따라, 다음의 Docker Object들을 생성하고 관리한다.<ul><li>Image<li>Container<li>Network<li>Data Volumes</ul><li>Docker Client는 Docker Daemon과 UNIX Socket 또는 REST API를 사용하여 통신을 하며, Docker Daemon이 Container를 구축, 실행 및 배포할 수 있도록 한다.<li>Docker Client와 Daemon은 동일한 시스템에서 실행될 수도 있고, Docker Client를 원격으로 Docker Daemon에 연결하여 사용할 수도 있다.</ul><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>REST API(Representational State Transfer API)
* API(Application Programming Interface)란?
  - 데이터와 기능의 집합을 제공하여 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환가능 하도록 하는것
* REST API정의
  - REST 기반으로 서비스 API를 구현한 것
  - 최근 OpenAPI(누구나 사용할 수 있도록 공개된 API: 구글 맵, 공공 데이터 등), 마이크로 서비스(하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처) 등을 제공하는 업체 대부분은 REST API를 제공한다.

REST API의 특징
- 사내 시스템들도 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.
- REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.
- 즉, REST API를 제작하면 델파이 클라이언트 뿐 아니라, 자바, C#, 웹 등을 이용해 클라이언트를 제작할 수 있다.
</pre></table></code></div></div><h2 id="registry"><span class="mr-2">Registry</span><a href="#registry" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>Image가 저장된 장소로 Private 또는 Public regsitry가 존재한다. Docker Hub 는 Docker, Inc에서 제공하는 Public registry다.<ul><li>Docker Hub는 GitHub와 같은 기능을 제공하고, 다른 사용자의 Image도 사용 가능하다.</ul></ul><h2 id="docker-image--container"><span class="mr-2">Docker Image &amp; Container</span><a href="#docker-image--container" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>이미지는 서비스 운영에 필요한 서버프로그램, 소스코드, 컴파일된 실행 파일을 묶은 형태이다.<li>저장소에 올리고 받는건 이미지이다.(Docker-hub)<li>이미지로 여러개의 컨테이너를 만들 수 있다.<li>운영체제로 치면 이미지는 실행파일이고 컨테이너는 프로세스이다.<li>인프라 환경을 컨테이너로 관리한다.<li>애플리케이션의 실행에 필요한 모든 파일 및 디렉토리들을 컨테이너로서 모아버린 것이다.</ul><h4 id="image"><span class="mr-2">Image</span><a href="#image" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Image는 Docker Container를 생성하기 위한 읽기 전용 Template이다. Image들은 다른 Image 기반 위에 Customizing이 추가되어 만들어질 수 있으며, 이렇게 만들어진 Image는 Docker Registry에 Push한 뒤 사용할 수 있다.</ul><h4 id="container"><span class="mr-2">Container</span><a href="#container" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Container는 Docker API 사용하여 생성, 시작, 중지, 이동 또는 삭제 할 수 있는 Image의 실행가능한 Instance를 나타낸다. Container를 하나 이상의 Network에 연결하거나, 저장 장치로 묶을 수 있으며, 현재 상태를 바탕으로 새로운 Image를 생성할 수도 있다.</ul><h4 id="service"><span class="mr-2">Service</span><a href="#service" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Service를 사용하면, 여러 개의 Docker Daemon들로 이루어진 영역 내에서 Container들을 확장(Scaling)시킬 수 있다.<li>Service는 ‘특정 시간동안 사용 가능한 Service의 Replica 개수’와 같은 상태 정보들을 직접 정의하여 사용할 수 있다.<li>기본적으로 Service는 Docker Daemon들 간의 Load Balancing을 제공하고 있기 때문에, 사용자 관점에서는 단일 Application으로 보인다.</ul><h4 id="docker의-image처리-방식레이어-저장-방식"><span class="mr-2">Docker의 Image처리 방식(레이어 저장 방식)</span><a href="#docker의-image처리-방식레이어-저장-방식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>도커 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 용량이 수백MB에 이른다. 처음 이미지를 다운 받을 땐 크게 부담이 안되지만 기존 이미지에 파일 하나 추가했다고 수백메가를 다시 다운받는다면 매우 비효율적이다.<li>도커는 이런 문제를 해결하기 위해 레이어라는 개념을 사용하고 유니온 파일 시스템을 이용하여 여러개의 레이어를 하나의 파일시스템으로 사용할 수 있게 해준다.<li>이미지는 여러개의 읽기 전용(read only) 레이어로 구성되고 파일이 추가되거나 수정되면 새로운 레이어가 생성된다.<li>ubuntu 이미지가 A + B + C의 집합이라면, ubuntu 이미지를 베이스로 만든 nginx 이미지는 A + B + C + nginx가 된다. web app 이미지를 nginx 이미지 기반으로 만들었다면 예상대로 A + B + C + nginx + source 레이어로 구성된다. web app 소스를 수정하면 A, B, C, nginx 레이어를 제외한 새로운 source(v2) 레이어만 다운받으면 되기 때문에 굉장히 효율적으로 이미지를 관리할 수 있다.</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/docker/'>Docker</a>, <a href='/categories/chapter-1-docker-%EC%86%8C%EA%B0%9C/'>Chapter 1(Docker 소개))</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/docker-intro/" class="post-tag no-text-decoration" >Docker Intro</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=1.+Docker+%EC%86%8C%EA%B0%9C+-+Banjung%60s+Blog&url=https%3A%2F%2Fhongwoojeon.github.io%2Fposts%2FChap1-Intro%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=1.+Docker+%EC%86%8C%EA%B0%9C+-+Banjung%60s+Blog&u=https%3A%2F%2Fhongwoojeon.github.io%2Fposts%2FChap1-Intro%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fhongwoojeon.github.io%2Fposts%2FChap1-Intro%2F&text=1.+Docker+%EC%86%8C%EA%B0%9C+-+Banjung%60s+Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Chap0-DesignPattern-Summary/">1. Design Pattern Summary</a><li><a href="/posts/UML_Diagram/">UML 다이어그램</a><li><a href="/posts/UseCase_Diagram/">Use Case 다이어그램</a><li><a href="/posts/Chap1-DesignPattern-%EA%B5%AC%EC%A1%B0/">1. Design Pattern 구조패턴</a><li><a href="/posts/Chap1-DesignPattern-%ED%96%89%EC%9C%84/">1. Design Pattern 행위패턴</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/docker-command/">Docker Command</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B3%B5%ED%95%99/">소프트웨어 공학</a> <a class="post-tag" href="/tags/akka-net/">Akka.net</a> <a class="post-tag" href="/tags/docker-container-controll/">Docker Container Controll</a> <a class="post-tag" href="/tags/docker-container-%ED%8C%8C%EC%9D%BC-%EC%84%A4%EC%A0%95/">Docker Container 파일 설정</a> <a class="post-tag" href="/tags/docker-container-%ED%99%98%EA%B2%BD-%EB%B0%8F-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/">Docker Container 환경 및 네트워크</a> <a class="post-tag" href="/tags/docker-container/">Docker Container</a> <a class="post-tag" href="/tags/docker-file/">Docker File</a> <a class="post-tag" href="/tags/docker-intro/">Docker Intro</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Chap0-1.DockerImage-Command/"><div class="card-body"> <em class="timeago small" data-ts="1648087200" > 2022-03-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>1. Docker Image</h3><div class="text-muted small"><p> ## 이미지 검색 &amp;gt; docker search hello-world ## 즐겨찾기 수가 1000이상의 이미지 검색 &amp;gt; docker search centos -s 1000 ## 이미지 다운로드 &amp;gt; docker image pull centos:7 ## 이미지 목록 표시 &amp;gt; docker image ls &amp;gt; docker imag...</p></div></div></a></div><div class="card"> <a href="/posts/Chap0-2.DockerContainer-Command/"><div class="card-body"> <em class="timeago small" data-ts="1648087200" > 2022-03-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>2. Docker Container</h3><div class="text-muted small"><p> ## 컨테이너 생성 &amp;gt; docker container create -it --name c1 centos ## 컨테이너 시작 &amp;gt; docker container start c1 ## 컨테이너 정지 &amp;gt; docker container stop c1 &amp;gt; docker container pause c2 ## 컨테이너 생성 및 시작 &amp;gt...</p></div></div></a></div><div class="card"> <a href="/posts/Chap0-4.DockerNetAndVolumn-Command/"><div class="card-body"> <em class="timeago small" data-ts="1648087200" > 2022-03-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>4. Docker Network & Volumn</h3><div class="text-muted small"><p> ## 컨테이너 환경변수 설정 &amp;gt; docker container run -d -e MYSQL_ROOT_PASSWORD=1234 --name db1 mysql ## 네트워크 목록 표시 &amp;gt; docker network ls ## 네트워크 상세 정보 확인 &amp;gt; docker network inspect bridge ## 네트워크 생성 &amp;gt;...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/PL_SQL_Procedure/" class="btn btn-outline-primary" prompt="Older"><p>오라클 프로시저(Procedure) 생성 및 실행</p></a> <a href="/posts/Chap2-ImageManage/" class="btn btn-outline-primary" prompt="Newer"><p>1. Image 관리</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://github.com/HongwooJeon">Banjung</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/docker-command/">Docker Command</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B3%B5%ED%95%99/">소프트웨어 공학</a> <a class="post-tag" href="/tags/akka-net/">Akka.net</a> <a class="post-tag" href="/tags/docker-container-controll/">Docker Container Controll</a> <a class="post-tag" href="/tags/docker-container-%ED%8C%8C%EC%9D%BC-%EC%84%A4%EC%A0%95/">Docker Container 파일 설정</a> <a class="post-tag" href="/tags/docker-container-%ED%99%98%EA%B2%BD-%EB%B0%8F-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/">Docker Container 환경 및 네트워크</a> <a class="post-tag" href="/tags/docker-container/">Docker Container</a> <a class="post-tag" href="/tags/docker-file/">Docker File</a> <a class="post-tag" href="/tags/docker-intro/">Docker Intro</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
