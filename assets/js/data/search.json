[ { "title": "인덱스 생성과 관리 & 사용자 관리", "url": "/posts/Chap3-1.%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%83%9D%EC%84%B1%EA%B3%BC-%EA%B4%80%EB%A6%AC/", "categories": "MongoDB, Chapter 3(인덱스 & 사용자 관리)", "tags": "인덱스 & 사용자 관리", "date": "2022-08-01 11:00:00 +0900", "snippet": "3.1 인덱스 생성과 관리&gt; db.emp.createIndex({eno:1}, {unique: true});&gt; db.emp.createIndex({job : -1});&gt;db.emp.getindexes() &lt;-- emp 컬렉션에 생성된 모든 인덱스를 출력한다.{ \"v\" : 1, \"key\" : { \"eno\" : 1 }, \"unique\" : true, \"ns\" : \"test.emp\" \"name\" : \"eno_1\"}&gt; db.emp.dropIndexes();&gt;db.emp.dropIndex({eno : -1}) &lt;-- 해당 인덱스를 삭제한다.&gt;db.runCommand({dropIndex: `emp`, index : {eno:-1}}) 일반적으로 DBMS에서 인덱스를 사용하는 이유는 빠른 데이터 검색을 수행하기 위함이다. MongoDB도 마찬가지로 사용한다. CreateIndex()로 인덱스를 생성한다. 인덱스 종류와 개수를 확인 할 때는 getIndexes()를 사용한다.3.2 인덱스 재 구성과 삭제&gt;db.emp.dropIndexes();&gt;db.emp.dropIndexes({eno : -1})&gt;db.runCommand({dropIndexes: `emp`, index :{eno:-1}})&gt; db.emp.reIndex() &lt;-- 기존 인덱스를 제거한 후 재생성한다.&gt; db.runCommand({reIndex : `emp`})- MongoDB에서 Index의 대소문자는 엄격히 구분됩니다.- Document를 Update할 때 해당 Index Key만 변경되지만 변경되는 Document 크기가 기존 EXTENT공간 크기보다 큰 경우에는 더 큰 EXTENT 공간으로 마이그레이션이 될 수 있기 때문에 성능 저하 현상이 발생할 수 있습니다.- sort() 절과 limit()절은 함께 사용하는 것이 성느에 도움이 됩니다. MongoDB에서 제공하는 Balance Tree 인덱스를 이용하면 데이터의 빠른 검색이 가능하다. 하지만, 입력과 삭제가 빈번하게 발생하는 경우에는 인덱스 구조의 변경으로 인한 불균형으로 빠른 성능이 보장되지 않을 수 있다. 위의 문제점을 해결할 수 있는 유일한 방법은 인덱스 구조를 재 구성하는 것이다.3.3 인덱스의 종류3.3.1 Single-key 인덱스와 Compound Key 인덱스 인덱스를 생성할 때 하나의 필드로 생성되는 Single-key 인덱스와 여러 개의 필드로 생성되는 복합-key에 알아보자.&gt; db.employees.createIndex({empnoL 1}) &lt;-- Single-key 인덱스(Asc:1, Desc: -1){ \"createdCollectionAutomatically\" : false, \"numIndexesBefore\" : 2, \"numIndexesAfter\" : 3, \"ok\" : 1}&gt; db.employees.createIndex({empno : 1, deptno : -1}) &lt;-- 복합-키 인덱스{ \"createdCollectionAutomatically\" : false, \"numIndexesBefore\" : 3, \"numIndexesAfter\" : 4, \"ok\" : 1}3.3.2 Non-Unique Index &amp; Unique Index Unique Index: 유일한 값이 저장되어 있는 필드에 생성한다. Non-Unique Index: 중복된 값이 저장되어 있는 필드에 생성한다.&gt; db.employees.createIndex({empno : 1}, {unique : true}) &lt;-- Unique Index&gt; db.employees.createIndex({ ename : 1}) &lt;-- Non-Unique Index3.3.3 Sparse 인덱스 검색 대상 필드의 값이 전체 컬렉션에서 차지하는 밀도가 낮은 경우에 생성하면 유리하다. 전체를 대상으로 Full Collection을 검색하는 것 보다 해당 조건을 만족하는 Document로 만 Sparse 인덱스를 생성하고 검색하기 때문에 빠른 성능을 기대할 수 있다. " }, { "title": "Chap4 Docker_file2", "url": "/posts/Chap4-Docker_File2/", "categories": "", "tags": "", "date": "2022-06-10 00:00:00 +0900", "snippet": "" }, { "title": "클래스 다이어그램", "url": "/posts/Class-Diagram/", "categories": "소프트웨어 공학, 클래스 다이어그램", "tags": "소프트웨어 공학", "date": "2022-06-01 11:00:00 +0900", "snippet": "클래스 다이어그램 시간에 따라 변하지 않는 시스템의 정적인 면을 보여주는 대표적인 UML 구조 다이어그램이다. 목적 시스템을 구성하는 클래스들 사이의 관계를 표현한다. 클래스란? 동일한 속성과 행위를 수행하는 객체의 집합 객체를 생성하는 설계도 즉, 클래스는 공통의 속성과 책임을 갖는 객체들의 집합이자 실제 객체를 생성하는 설계도이다. 클래스는 변화의 기본 단위이다. 디자인 패턴을 제대로 이해하려면 만들어진 프로그램을 흔들어보고 어떤 것이 변화되는지를 잘 살펴봐야 한다. UML 클래스 표현 상단: 클래스의 이름 중간: 속성(클래스의 특징) 하단: 연산(클래스가 수행하는 책임) 경우에 따라 속성과 연산 부분은 생략할 수 있다. 속성과 연산의 가시화를 정의한다. 접근 제어자 표시 설명 public + 어떤 클래스의 객체에서든 접근이 가능하다. private - 해당 클래스의 객체내에서만 접근이 가능하다. protected # 해당 클래스와 동일 패키지 or 상속 관계에 있는 하위 클래스만 접근가능하다. pakage ~ 동일 패키지에 있는 클래스의 객체만 접근이 가능하다. 분석 단계와 설계 단계에서의 클래스 다이어그램관계 UML에서 제공하는 클래스들 사이의 관계 관계 표시 설명 연관 관계 실선 OR 화살표 클래스들이 개념상 서로 연결되었음을 나타낸다. 보통 한 클래스가 다른 클래스에서 제공하는 기능을 사용하는 상황일 때 표시한다. 일반화 관계 속이 빈 화살표 객체지향 개념에서는 상속 관계라고 한다. 집약 관계 속이 빈 다이아몬드 클래스들 사이의 전체 또는 부분 같은 관계를 나타낸다. 전체 객체의 라이프타임과 부분 객체의 라이프 타임은 독립적이다. 합성 관계 속이 찬 다이아몬드 클래스들 사이의 전체 또는 부분 같은 관계를 나타낸다. 전체 객체의 라이프타임과 부분 객체의 라이프 타임은 의존적이다. 의존 관계 점선 화살표 연관 관계와 같이 한 클래스가 다른 클래스에서 제공하는 기능을 사용할 때를 나타낸다. 차이점은 두 클래스의 관계가 한 메서드를 실행하는 동안과 같은, 매우 짧은 시간만 유지된다. 실체화 관계 빈 삼각형과 점선 책임들의 집합인 인터페이스와 이 책임들을 실제로 실현한 클래스들 사이의 관계를 나타낸다. 연관 관계 한 클래스가 다른 클래스와 연관 관계를 가지면 각 클래스의 객체는 해당 연관 관계에서 어떤 역할을 수행한다. 두 클래스 사이의 연관 관계가 명확한 경우에는 연관 관계 이름을 사용하지 않아도 된다. 역할 이름은 실제 프로그램을 구현할 때 연관된 클래스의 객체들이 서로를 참조할 수 있는 속성의 이름으로 활용할 수 있다. 연관 관계는 방향성을 가질 수 있다. 양방향은 실선으로, 단방향은 화살표로 표시한다. 화살표 단방향 연관 관계 한 쪽은 알지만 다른 쪽을 상대방의 존재를 모른다. 실선 양방향 연관 관계 두 클래스의 객체들이 서로의 존재를 인식한다. 일반적으로 다대다 연관 관계는 양방향 연관 관계로 표현하는 것이 적절하다. 하지만 양방향 연관 관계를 구현하는 것은 복잡하기 때문에 보통 다대다 연관 관계를 일대다 단방향 연관 관계로 변환해 구현한다. 연관 클래스 연관 관계에 추가할 속성이나 행위가 있을 때 사용한다. 연관 클래스는 연관 관계가 있는 두 클래스 사이에 위치하며, 점선을 사용해 연결한다. 이 연관 클래스를 일반 클래스로 변환하여 다대다에서 일대다 연관 관계로 변환한다. 다중성 표시방법 다중성 표기 의미 1 엄밀하게 1 * or 0..* 0 or 그 이상 1..* 1 or 그 이상 0..1 0 or 1 1,2,5 1 or 2 or 5 선에 아무런 숫자가 없으면 1:1 관계이다. 일반화 관계 한 클래스가 다른 클래스를 포함하는 상위 개념일 때 두 클래스 사이에는 일반화 관계가 존재한다. 객체지향 개념에서는 일반화 관계를 상속 관계라고 한다. 부모 클래스(가전제품) 추상적인 개념(실제로 존재하지 않는다.) 삼각형 표시가 있는 쪽이다. 자식 클래스 구체적인 개념 삼각형 표시가 없는 쪽 부모 클래스는 자식 클래스의 공통 속성이나 연산을 제공하는 틀이다. 예를 들어 가전 제품 클래스에 제조번호, 제조년도, 제조회사와 같은 공통 속성과 켜기, 끄기와 같은 공통 연산을 두고 이를 상속받아 세탁기, TV, 식기 세척기와 같은 자식 클래스에서 사용하면 된다. 추상 클래스 추상 메서드를 하나 이상 가지는 클래스 추상 메서드 부모 클래스에서 구현되지 않은 빈 껍데기만 있는 연산 예를 들어, 위의 켜기, 끄기는 자식 클래스마다 다르기 때문에 부모 클래스인 가전 제품에서 해당 연산에 대한 정의를 하지 않고 빈 껍데기만 있는 연산을 제공한다. 추상 클래스는 다른 일반적인 클래스와는 달리 객체를 생성할 수 없다. UML에서는 추상 클래스와 추상 메서드를 표현한다. 집합 관계 UML 연관 관계의 특별 경우로 전체와 부분의 관계를 명확하게 명시하고자할 때 사용한다.집약 관계(aggregation) 한 객체가 다른 객체를 포함하는 것(부분을 나타내는 객체를 다른 객체와 공유할 수 있다.) 전체를 가리키는 클래스 방향에 빈 마름모로 표시한다. 전체 객체의 라이프타임과 부분 객체의 라이프 타임은 독립적이다. 예&gt; 생성자에서 참조값을 인자로 받아 필드를 세팅한다.public class Computer{ private MainBoard mb; private CPU c; public Computer(MainBoard mb, CPU c) { this.mb = mb; this.c = c; }}합성 관계(composition) 부분 객체가 전체 객체에 속하는 관계 전체를 가리키는 클래스 방향에 채워진 마름모로 표시한다. 전체 객체의 라이프타임과 부분 객체의 라이프 타임은 의존적이다. 예&gt; 생성자에서 필드에 대한 객체를 생성한다. public class Computer{ private MainBoard mb; private CPU c; public Computer() { this.mb = new MainBoard(); this.c = new CPU(); }} 의존 관계 일반적으로 한 클래스가 다른 클래스를 사용하는 경우 클래스의 속성(멤버 변수)에서 참조할 때 연산의 인자(참조 값)로 사용 될 때 Method 내부의 지역 객체로 참조 될 때 연관 관계와 의존 관계의 차이 연관 관계 오랜 시간 동안 같이할 객체와의 관계 예&gt; 자동차와 소유한 사람의 관계 public Person{ private Car owns; public void setCar(Car car) { this.owns = car; } public Car getCar() { return this.owns; }} 의존 관계 짧은 시간 동안 이용하는 관계 UML에서 점선으로 나타낸다. 예&gt; 자동차와 주유기의 관계 public class Car{ public void fillGas(GasPump p) { p.GetGas(amount); }}인터페이스와 실체화 관계 인터페이스란 책임이다. 어떤 객체의 책임이란 객체가 해야 하는 일 or 객체가 할 수 있는 일이다. 즉, 객체가 외부에 제공하는 서비스나 기능은 객체가 수행하는 책임으로 본다. 어떤 공통되는 능력이 있는 것들을 대표하는 관점이다. UML에서 Interface의 표현방법 Interface: 클래스에 사용하는 사각형을 그대로 사용하고 인터페이스 이름 위에 스테레오 타입이로 interface를 표시한다. 빈 삼각형과 점선을 사용한다. " }, { "title": "Use Case 다이어그램", "url": "/posts/UseCase_Diagram/", "categories": "소프트웨어 공학, UseCase 다이어그램", "tags": "소프트웨어 공학", "date": "2022-05-20 11:00:00 +0900", "snippet": "유스케이스 다이어그램(Use Case Diagram) 시스템에서 제공해야하는 기능이나 서비스를 명세하는 단계로 사용자와 시스템 사이의 상호작용을 보여준다.시스템 범위 위의 예제를 살펴 봤을 때, 많은 사람들이 위 Use case 다이어그램이 ATM시스템을 모델링하고 잇는 중 이라는 것을 알 수 있다. 왜냐하면 커다란 네모에 ATM으로 쓰여져 있기 때문이다. 즉, 우리가 개발하고자 하는 시스템은 사각형으로 표시한다는 것을 자연스레 알 수 있다.유스케이스(Usecase) 위 예제에서 사각형 안에 동그라미는 뭘까? 이것이 바로 유스케이스이다. 시스템이 어떤 서비스 or 기능을 제공하는지를 명시해 주는 것으로 타원형으로 표시한다. 유스케이스의 이름은 상호작용 수행의 목적을 단순하고 명료하게 기술한다. 위 예제의 ATM 시스템은 예금, 조회, 시스템 구동, 시스템 종료, 사용자 인증 기능을 제공해야 한다.액터(Actor) 액터는 시스템 외부에 존재하며 시스템과 상호작용을 하는 모든 것을 나타낸다. 시스템을 사용하게 될 사람은 물론이고, 다른 외부에 있는 시스템도 포함된다.1. 프라이머리 엑터(Primary actor) 시스템을 사용함으로서 이득을 얻는 엑터로 보통 외부 객체가 사람일때를 말하며 사람모양으로 표기한다. 보통 시스템의 왼쪽에 그린다.= 위 예제에서는 ATM을 이용하는 액터는 사용자, 관리자 라는 뜻이다.2. 세컨더리 액터(Secondary actor) 프라이머리 액터가 이득을 얻기위해 도움을 주는 액터로 보통 외부 시스템을 의미하며 박스에 «actor»를 입력하여 표기한다. 보통 시스템의 오른쪽에 그려준다. 위 예제에서는 ATM을 도와주는 외부 시스템으로 인증, 은행 시스템이 있다. 참고 액터이름은 구체적이면 안된다.관계(Relationship) 유스케이스 다이어그램에서 관계는 엑터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타나며 서로 상호작용을 한다는 의미로 해석하면 3가지 종류의 관계가 있다.1. 포함 관계(필수적 관계) 위 예제의 시스템을 보면 구동이나 시스템 종료나 시스템의 여러 기능을 사용하기 전 사용자 인증을 받아야한다. 관라지인지 확인도 안되었는데 시스템을 구동하거나 종료하게 되면 안된다. 사용자 인증이란 기능은 공통적으로 많이 쓰이는데 이렇게 여러 유스케이스에서 중복되는 경우 따로 떼어내어 새로운 유스케이스를 만드는 경우를 포함관계라고 한다. 표기 방법 원래의 유스케이스에서 새롭게 만들어진 유스케이스 방향으로 화살표를 점섬으로 연결하고 &lt;&lt;include&gt;&gt;를 표기한다. 2. 일반화 관계 보편적인 유스케이스와 구체적인 유스케이스 사이에 존재한다. 표기 방법 구체적인 유스케이스에서 일반화된 유스케이스 방향으로 끝부분이 삼각형 테두리로 표현된 화살표를 실선으로 연결하여 표현한다. 3. 확장 관계(선택적 관계) 유스케이스가 특정한 조건이 만족되는 경우에만 실행되는 단계를 확장관계로 표현한다. 표기 방법 특정한 조건이 만족하는 경우에만 실행되는 단계를 따로 유스케이스로 만들고 원래의 유스케이스 방향으로 화살표를 점선으로 연결한 후 &lt;&lt;extend&gt;&gt;를 표기해준다. 예제 다음을 만족하는 유스케이스 다이어그램을 표현한다. 게시판 시스템을 만들려고 한다. 엑터는 사용자가 있다. 사용자는 글을 만들수도 수정 할 수도 있다. 글을 쓰거나 수정하는 경우 로그인을 해야한다. 글을 작설할 때, 경우에 따라서 그림파일을 업로드 할 수 있어야 한다. 잘못된 유스케이스 다이어그램 예제의 왼쪽은 유스케이스 다이어그램을 흐름도처럼 그린 경우이다. 유스케이스 다이어그램을 작성할 때, 흐름도를 작성하는 것처럼 그려서는 안된다. 유스케이스 간의 관계는 포함, 확장, 일반화 관계만 존재하고 실행순서 관계는 나타내지 않아야한다. 예제의 오름쪽 유스케이스는 포함관계를 과도하게 하용하는 경우이다. 의도는 물품구매가 로그인 단계와 물품조회 단꼐를 포함하기 때문에 포함관계로 연결하였으나 일반적으로 포함 관계는 여러개의 유스케이스가 서로 공통적인 부분을 갖고있는 경우에 중복된 부분을 분리하여 표현하고자 할 때 사용한다. 예제처럼 물품 조회가 다른 물품 구매를 제외한 다른 유스케이스에 전혀 사용되지 않는다면 이를 포함관계로 할 필요가 없다. 올바르게 수정한 유스케이스 다이어그램" }, { "title": "UML 다이어그램", "url": "/posts/UML_Diagram/", "categories": "소프트웨어 공학, UML 다이어그램", "tags": "소프트웨어 공학", "date": "2022-05-20 11:00:00 +0900", "snippet": "소프트웨어 개발과 모델링 개발자가 소프트웨어를 개발하는 이유는 고객의 문제를 해결하기 위해서이다. 개발에 있어 가장 우선적으로 해야 할 일은 문제를 이해하는 것이다. 이 때, 문제를 잘 해결하기 위해서 하는 것이 모델링 이다. 애자일 기법이든 폭포수 모델이든 분석, 설계, 구현, 테스트 과정을 거친다. 실제로 개발하는 단계는 구현 단계여야한다. 즉 모델링은 이 구현단계 전에 해야하여 이 때, 사용하는 언어가 UML이다.UML 다이어그램 UML(Unified Modeling Language)란? 시스템 개발자가 자신의 비전을 구축하고 반영하는데 있어 표준적이고 이해하기 쉬운 방법으로 할 수 있도록 도와주며, 자신의 설계 결과물을 다른사람에게 효과적으로 공유할 수 있는 메커니즘을 제공한다. 시스템: 비즈니스 문제에 대한 솔루션을 제공하는 S/W와 H/W가 합쳐진 개념 시스템 개발: 고객이 필요로 하는 시스템을 만드는 것 고객: 솔루션을 필요로하는 사람 분석가: 고객의 문제를 문서화하여 개발자에게 전달하는 역할 개발자: 문제를 해결할 수 있는 S/W를 만드는 사람 UML의 구성요소(뷰, 모델) 목적: 시스템을 여러가지 시각에서 볼 수 있는 뷰(View)를 제공한다. 이러한 뷰의 집합을 모델(Model)이라고 한다. UML 다이어그램의 종류구조 다이어그램(Structure Diagram) 종류 설명 클래스(Class) 다이어그램 시스템을 구성하는 클래스들 사이의 관계를 표현한다. 객체(Object) 다이어 그램 객체 정보를 표현한다. 복합체 구조(Composite Structure) 다이어그램 복합 구조의 클래스와 컴포넌트 내부 구조를 표현한다. 배치(Deployment) 다이어그램 S/W, H/W, Network를 포함한 실행 시스템의 물리 구조를 표현한다. 컴포넌트(Component) 다이어그램 컴포넌트 구조 사이의 관계를 표현한다. 패키지(Package) 다이어그램 클래스트 UseCase등을 포함한 여러 모델 요소들을 그룹화해 패키지를 구성하고 패키지들 사이의 관계를 표현한다. 행위 다이어그램(Structure Diagram) 종류 설명 활동(Activity) 다이어그램 업무 처리 과정이나 연산이 수행되는 과정을 표현한다. 상태 머신(State machine) 다이어그램 객체의 생명주기를 표현한다. 유즈 케이스(Use case) 다이어그램 사용자 관점에서 시스템 행위를 표현한다. 순차(Sequence) 다이어그램 시간 흐름에 따른 객체사이의 상호작용을 표현한다. 상호작용 개요(Interation overview) 다이어그램 여러 상호작용 다이어그램 사이의 제어 흐름을 표현한다. 통신(Communication) 다이어그램 객체 사이의 관계를 중심으로 상호작용을 표현한다. 타이밍(Timing) 다이어그램 객체 상태 변화와 시간 제약을 명시적으로 표현한다. " }, { "title": "UnbondingPriorityMailBox", "url": "/posts/Chap0-Dispatcher/", "categories": "Akka.net, Etc", "tags": "Akka.net", "date": "2022-05-16 11:00:00 +0900", "snippet": "Akka.Net Dispatcher(C#)UnbondingPriorityMailBox 메시지 큐에 N개의 메시지가 대기중이어서 긴급하게 처리해야 하는 메시지가 줄을 설 때, 특정 메시지를 먼저 처리하도록 하는 옵션 .config 파일 My-mailBox{ mailbox-type = \"Mirero.IRIS.MessagePriority.Sample.Actors.MyMailBox, Mirero.IRIS.MessagePriority.Sample\"} akka.actor.deployment{ /OnlyReceiveActor\t{\t\trouter = round-robin-pool\t\tnr-of-instances = 1 mailbox = My-mailBox\t}\t/PriorityActor\t{\trouter = round-robin-pool\tnr-of-instances = 1\t}\t/SendingActor\t{\trouter = round-robin-pool\tnr-of-instances = 1\t}} MailBox.cs public class MyMailBox : UnboundedStablePriorityMailbox { public MyMailBox(Settings settings, Config config) : base(settings, config) { } protected override int PriorityGenerator(object message) { ReceiveMessage msg = (message as ReceiveMessage); return msg.Priority;##0:high priority ##1:low priority } } Actor 생성 Akka.Actor.Props.Create(() =&gt; new OnlyReceiveActor()) .WithRouter(FromConfig.Instance) .WithMailbox(\"My-mailBox\"); 테스트 결과Sending 1Sending 2Sending 3Priority 1Priority 2Priority 3Sending 4Sending 5" }, { "title": "1. Design Pattern 행위패턴", "url": "/posts/Chap1-DesignPattern-%ED%96%89%EC%9C%84/", "categories": "Design Pattern, Chapter 3(행위패턴)", "tags": "Design Pattern", "date": "2022-05-01 11:00:00 +0900", "snippet": "1. Chain of Responsibility 요청을 처리할 수 있는 기회를 하나 이상의 객체에게 부여함으로써 요청하는 객체와 처리하는 객체사이의 결합도를 없애려는 것이다. 요청을 해결할 객체를 만날 때까지 객체 고리를 따라서 요청을 전달한다.1.1 구조1.2 설명 Handler: 요청을 처리하는 인터페이스를 정의하고, 다음번 처리자와의 연결을 구현한다. 즉, 연결 고리에 연결된 다음 객체에게 다시 메시지를 보낸다. ConcreteHandler: 책임져야 할 행위가 있다면 스스로 요청을 처리한다. 다음번 처리자에 접근할 수 있다. 즉, 자신이 처리할 행위가 있으면 처리하고, 그렇지 않으면 다음번 처리자에게 다시 처리를 요청한다. Client: ConcreteHandler 객체에게 필요한 요청을 보낸다.2. Command 요청을 객체로 캡슐화함으로써, 서로 다른 요청으로 클라이언트를 파라미터화 하고, 요청을 저장하거나 기록을 남겨서 오퍼레이션의 취소도 가능하게 한다.2.1 구조2.2 설명 Command: 오퍼레이션 수행에 필요한 인터페이스 선언. ConcreteCommand: Receiver 객체와 액션 간의 연결성을 정의한다. 또한 처리 객체에 정의된 오퍼레이션을 호출하도록 Execute 를 구현한다. Client: ConcreteCommand 객체를 생성하고 처리 객체로 정의한다. Invoker: 명령어에게 처리를 수행할 것을 요청한다. Receiver: 요청에 관련된 오퍼레이션 수행방법을 알고 있다.3. Interpreter 언어에 따라서 문법에 대한 표현을 정의한다. 언어의 문장을 해석하기 위해 정의한 표현에 기반하여 분석기를 정의한다.3.1 구조3.2 설명 AbstractExpression: 추상 구문 트리에 속한 모든 노드에 해당하는 클래스들이 공통으로 가져야 할 Interpret() 오퍼레이션을 추상 오퍼레이션으로 정의한다. TerminalExpression: 문법에 정의한 터미널 기호와 관련된 해석 방법을 구현한다. 문장을 구성하는 모든 터미널 기호에 대해서 해당 클래스를 만들어야 한다. NonterminalExpression: 문법의 오른편에 나타나는 모든 기호에 대해서 클래스를 정의해야 한다. 문법에R :: = R1 R2 … Rn을 정의하고 있다면 R 에 대해서 NonterminalExpression 에 해당하는 클래스를 정의해야 한다. 또한 규칙의 오른쪽에 나타난 R1 에서 Rn 에 이르기까지의 모든 기호에 대응하는 인스턴스 변수들을 정의해야 한다. 또한 터미널 기호가 아닌 모든 기호들에 대해서 Interpret() 오퍼레이션을 구현해야 한다. 이 Interpret() 오퍼레이션은 R1 에서 Rn 에 이르기까지의 각 인스턴스 변수를 재귀적으로 호출하는 것이 일반적이다. Context: 번역기에 대한 포괄적인 정보를 포함한다. Client: 언어로 정의한 특정 문장을 나타내는 추상 구문 트리이다. 이 추상 구문 트리는 NonterminalExpression 과 TerminalExpression 클래스의 인스턴스로 구성된다. 이 인스턴스의 Interpret() 오퍼레이션을 호출한다.4. Iterator 내부 표현방법을 노출하지 않고 복합 객체의 원소를 순차적으로 접근할 수 있는 방법을 제공한다. 4.1 구조 4.2 설명 Iterator: 요소를 접근하고 순회하는데 필요한 인터페이스 제공. ConcreteIterator: Iterator 에 정의된 인터페이스를 구현하는 클래스로서 순회 과정 중에 집합 객체 내의 현재 위치를 기억한다. Aggregate: Iterator 객체를 생성하는 인터페이스를 정의 ConcreteAggregate: 해당하는 ConcreteIterator 의 인스턴스를 반환하도록 Iterator 생성 인터페이스를 구현한다.5. Mediator 객체들 간의 상호작용을 객체로 캡슐화한다. Mediator 패턴은 객체들 간의 참조관계를 객체에서 분리함으로써 상호작용만을 독립적으로 다양하게 확대할 수 있다.5.1 구조5.2 설명 Mediator: Colleague 객체와 교류하는 데 필요한 인터페이스를 정의한다. ConcreteMediator: Colleague 객체와 조화를 이룸으로써 이루어지는 협력 행위를 구현하고 자신의 colleague 가 무엇인지를 알고 이를 관리한다. Colleague: Mediator 객체가 누구인지를 안다. 다른 객체와 연결성을 필요하면 Mediator 를 통해 이루어지도록 한다.6. Memento 캡슐화를 위배하지 않고 객체 내부상태를 객체화 하여, 나중에 객체가 이 상태로 복구 가능하게 한다. 6.1 구조 6.2 설명 Memento: Originator 객체의 내부 상태를 저장한다. 메멘토는 originator 객체의 내부 상태를 필요한 만큼 저장해 둔다. originator 객체를 제외한 다른 객체는 Memento 클래스에 접근할 수 없다. 그래서 Memento 클래스는 두 개의 인터페이스를 갖는다. 관리 책임을 갖는 객체인 CareTaker 클래스는 Memento 에 정의된 모든 인터페이스를 다 보지 못하고 단지 Memnto 를 다른 객체에 전달한다. 이에 비해 Originator 클래스는 자신의 상태를 이전 상태로 복구하기 위해 필요한 모든 자료에 접근하는데 필요한 Memento 의 다양한 인터페이스를 사용할 수 있다. 즉, 메멘도를 생성하는 Originator 클래스만이 메멘토의 내부상태에 접근할 수 있는 권한을 갖는다. Originator: 메멘토를 생성하여 현재 객체의 상태를 저장하고 내부 상태를 복구한다. Caretaker: 메멘토의 보관을 책임지기는 하지만, 메멘토의 내용을 확인하거나 처리하지는 않는다.7. Observer 객체 사이에 1:N 의 종속성을 정의하고 한 객체의 상태가 변하면 종속된 다른 객체에 통보가 되고 자동으로 수정한다.7.1 구조7.2 설명 Subject: 관찰자들을 알고 있다. 다수의 Observer 객체는 대상을 관찰한다. Observer 객체를 대상과 연결하거나 무관한 것으로 만드는 데 필요한 인터페이스를 갖는다. Observer: 대상에 생긴 변화에 관심 있는 객체를 변경하는데 필요한 인터페이스를 갖고 있다. 이로써 Subject 의 변경에 따라 변화되어야 하는 객체들의 일관성을 유지한다. ConcreteObserver: ConcreteSubject 객체에 대한 참조자를 관리한다. 대상과 일관성을 유짛해야 하는 상태를 저장하고 있다. 대상과 일관성을 유지하기 위해 관찰자를 수정해야 하므로 이에 필요한 인터페이스를 구현한다.8. State 객체의 내부 상태에 따라 행위를 변경할 수 있게한다. 이렇게 하면, 객체는 마치 클래스를 바꾸는 것처럼 보인다. 8.1 구조 8.2 설명 Context: 클라이언트가 관심을 갖고 있는 인터페이스를 정의한다. ConcreteState 서브클래스의 인스턴스를 관리하고 있는데, ConcreteState 의 서브클래스들이 객체의 현재 상태를 정의하고 있다. State: Context 가 갖는 각 상태별로 필요한 행위를 캡슐화하여 인터페이스로 정의한다. ConcreteState Subclass: 각 서브클래스들은 Context 의 상태에 따라 처리되어야 할 실제 행위를 구현하고 있다.9. Strategy 알고리즘군이 존재할 경우, 각각의 알고리즘을 별도의 클래스로 캡슐화하고 이들을 상호 교환 가능한 것으로 정의한다. Strategy 패턴은 클라이언트에 영향을 주지 않고 독립적으로 알고리즘을 다양하게 변경할 수 있게한다.9.1 구조9.2 설명 Strategy: 제공하는 모든 알고리즘에 대한 공통의 오퍼레이션들을 인터페이스로 정의한다. Context 클래스는 ConcreteStrategy 클래스에 정의한 인터페이스를 통해서 실제 알고리즘을 사용한다. ConcreteStrategy: Strategy 인터페이스를 실제 알고리즘으로 구현한다. Context: ConcreteStrategy 객체가 무엇인지 구체화한다. 즉, Strategy 객체에 대한 참조자를 관리하고, 실제로는 Strategy 서브클래스의 인스턴스를 갖고 있음으로써 구체화한다. 또한 Strategy 가 자료에 접근해가는데 필요한 인터페이스를 정의한다.10. Template Method 오퍼레이션에는 알고리즘의 처리 과정만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스에 정의한다. Template Method 패턴은 알고리즘의 처리 과정은 변경하지 않고 알고리즘 각 단계의 처리를 서브클래스에서 재정의할 수 있게한다.10.1 구조10.2 설명 AbstractClass: 서브클래스들이 반드시 구현해야 하는 알고리즘 처리 단계 내의 기본 오퍼레이션이 무엇인지를 정의한다. 서브클래스에서 이들 오퍼레이션들을 구현한다. 이 클래스에서 템플릿 메소드를 구현하는데, 그 방법은 알고리즘의 기본 골격 구조를 정의하여 템플릿 메소드가 다른 객체에 의해 정의된 오퍼레이션뿐만 아니라 인터페이스로 정의된 기본 오퍼레이션을 재정의한 서브클래스에게 메시지가 전달되어 기본 골격 구조를 준수하되 다른 결과가 나타나게 된다. ConcreateClass: 서브클래스마다 기본 오퍼레이션을 다르게 구현한다.11. Visitor 객체 구조의 요소들에 수행할 오퍼레이션을 표현한 패턴이다. Visitor 패턴은 오퍼레이션이 처리할 요소의 클래스를 변경하지 않고도 새로운 오퍼레이션을 정의할 수 있게한다. 11.1 구조 11.2 설명 Visitor: 각 ConcreteElement 클래스에 대한 Visit 오퍼레이션을 선언한다. 오퍼레이션의 이름과 인터페이스 형태는 Visit() 요청을 보내는 방문자에게 보내는 클래스를 명시한다. 이로써 방문자는 방문할 요소의 실제 서브클래스를 결정한다. 그리고 나서 방문자는 Element 가 제공하는 인터페이스를 통해 직접 Element 객체에 접근할 수 있다. ConcreteVisitor: Visitor 클래스에 정의된 오퍼레이션을 구현한다. 각 오퍼레이션은 객체에 해당하는 클래스에 정의된 알고리즘을 구현한다. ConcreteVisitor 클래스는 내부 상태를 저장하고 있으며, 알고리즘이 운영될 수 있는 상황 정보를 제공한다. ConcreteVisitor 클래스가 저장하고 있는 내부 상태는 구조의 순회 과정에서 도출되기도 한다. Element: 아규먼트로 Visitor 클래스를 받아들이는 Accept() 오퍼레이션을 정의한다. ConcreteElement: 아규먼트로 Visitor 객체를 받아들이는 Accept() 오퍼레이션을 구현한다. ObjectStructure: 요소들을 나열하고 방문자로 하여금 이들 요소에 접근하게 하는 인터페이스를 제공한다. ObjectStructure 는 Composite 패턴의 복합 객체일 수도 있고, 리스트나 집합과 같은 컬렉션일 수도 있다." }, { "title": "1. Design Pattern 구조패턴", "url": "/posts/Chap1-DesignPattern-%EA%B5%AC%EC%A1%B0/", "categories": "Design Pattern, Chapter 2(구조패턴)", "tags": "Design Pattern", "date": "2022-04-24 11:00:00 +0900", "snippet": "1. Adapter 클래스의 인터페이스를 클라이언트가 기대하는 다른 인터페이스로 변환한다. Adapter 패턴은 호환이 안되는 인터페이스 때문에 함께 사용할 수 없는 클래스를 개보하여 작동하도록 해준다.1.1 구조 다중상속을 활용해서 설계한 Adapter 패턴 객체합성에 의한 Adapter 패턴1.2 설명 Target: 클라이언트가 사용할 도메인에 종속적인 인터페이스를 정의하고 있는 클래스이다. Client: Target 인터페이스를 만족하는 객체와 동작할 대상이다. Adaptee: 인터페이스 개조가 필요한 기존의 인터페이스를 정의하고 있는 클래스이다. Adapter: Target 인터페이스에 Adaptee 의 인터페이스를 맞춰주는 클래스2. Bridge 추상화와 구현을 분리하여 각각을 독립적으로 변형할 수 있게한다. 구현과 추상화 개념을 분리하여 구현 자체도 하나의 추상화 개념으로 다양한 변형이 가능하고 구현과 독립적으로 인터페이스도 다양함을 가질수 있다.2.1 구조2.2 설명 Abstraction: 추상화 개념에 대한 인터페이스를 제공하고 객체 구현자(Implementor)에 대한 참조자를 관리한다. RefinedAbstraction: 추상화 개념에 정의된 인터페이스를 확장한다. Implementor: 구현 클래스에 대한 인터페이스를 제공한다. 다시 말해서 실질적인 구현을 제공한 서브클래스들에 있어서 공통적인 오퍼레이션의 시그니처만을 정의하고 있다. 이 인터페이스는 Abstraction 클래스에 정의된 인터페이스에 정확하게 대응할 필요가 없다. 즉, 두 인터페이스는 서로 다른 형태일 수 있다. 일반적으로 Implementor 인터페이스는 기본적인 구현 오퍼레이션을 수행하고 Abstraction 은 보다 추상화된 서비스 관점의 인터페이스를 제공한다. 그러므로 서비스 관점의 인터페이스를 구현하기 위해서 Implementor 에 정의된 여러 개의 오퍼레이션이 필요할 수도 있는 것이다. ConcreteImplementor: Implementor 인터페이스를 구현하는 것으로 실제적인 구현 내용을 담고 있다. 구현 방식이 달라지면 지속적으로 만들어지는 클래스이다.3. Composite 부분/전체 계층을 나타내기 위해 복합 객체를 트리 구조로 생성한다. 클라이언트가 개별적 객체와 복합 객체 모두를 동일하게 다루도록 한다.3.1 구조3.2 설명 Component: 집합 관계에 정의될 모든 객체에 대한 인터페이스를 정의한다. 모든 클래스에 해당하는 인터페이스에 대해서는 공통의 행위를 구현한다. 전체 클래스에 속한 요소들을 관리하는데 필요한 인터페이스를 정의한다. 순환 구조에서 요소들을 표함하는 전체 클래스로의 접근에 필요한 인터페이스를 정의한다. 필요하다면 공통의 행위는 구현할 수 있다. Leaf: 집합 관계에서의 다른 객체를 포함할 수는 없고 포함되기만 하는 객체로 객체에 가장 기본이 되는 행위를 정의한다. Composite: 포함된 요소들을 갖는 복합 객체에 대한 행위를 정의한다. 자신이 합성하고 있는 요소들을 저장하고 있으면서, 각 합성 요소를 다루는데 관련된 오퍼레이션을 구현한다. Client: Component 인터페이스를 통해 집합 관계에 있는 객체들을 관리한다.4. Decorator 객체에 동적으로 책임을 추가할 수 있게한다. 기능의 유연한 확장을 위해 상속대신 사용할 수 있는 방법이다.4.1 구조4.2 설명 Component: 동적으로 추가할 서비스를 가질 가능성이 있는 객체들에 대한 인터페이스 ConcreteComponent: 추가적인 서비스가 실제로 정의되어야 할 필요가 있는 객체 Decorator: Component 객체에 대한 참조자를 관리하면서 Component 에 정의된 인터페이스를 만족하도록 인터페이스를 정의 ConcreteDecorator: Component 에 새롭게 추가할 서비스를 실제로 구현하는 클래스이고 Decorator 에 정의된 기본 오퍼레이션을 만족하면서, 추가적인 행위를 addBehavior 로 또는 addedState 로 처리한다.5. Façade 서스 시스템에 있는 인터페이스 집합에 대해서 하나의 통한된 인터페이스를 제공한다. 서브시스템을 좀 더 사용하기 편하게 하기 위해서 높은 수준의 인터패이스를 정의한다.5.1 구조5.2 설명 Facade: 단순하고 일관된 통합 인터페이스를 제공하며, 서브시스템을 구성하는 어떤 클래스가 어떤 요청을 처리해야 하는지를 알고 있으며, 클라이언트의 요청을 해당하는 서브시스템 객체에 전달한다. Subsystem Classes: 서브시스템의 기능성을 구현하고, Façade 객체에 의해 할당된 작업을 실제로 처리하지만 Façade 에 대한 아무런 정보를 갖고 있지 않다. 6. Flyweight 작은 크기의 객체들이 여러 개 있는 경우, 객체를 효과적으로 사용하는 방법으로 객체를 공유하게 한다.6.1 구조6.2 설명 Flyweight: Flyweight 가 받아들일 수 있고, 부가적 상태에서 동작해야 하는 인터페이스를 선언하고 있다. ConcreteFlyweight: Flyweight 인터페이스를 구현하고 내부적으로 갖고 있어야 하는 본질적 상태에 대한 저장소를 정의하고 있다. ConcreteFlyweight 객체는 공유할 수 있는 것이어야 한다. 그러므로 관리하는 어떤 상태라도 본질적인 것이어야 한다. UnsharedConcreteFlyweight: 모든 Flyweight 서브클래스들이 공유될 필요는 없다. Flyweight 인터페이스는 공유를 가능하게 하지만 그것을 강요해서는 안 된다. UnsharedConcreteFlyweight 객체가 ConcreteFlyweight 객체를 자신의 자식으로 갖는 것은 흔한 일이다. FlyweightFactory: Flyweight 객체를 생성하고 관리한다. Flyweight 가 적절히 공유되도록 보장해야 한다. 클라이언트가 Flyweight 를 요청하면 FlyweightFactory 객체는 이미 존재하는 인스턴스를 제공하거나, 만약 존재하지 않는다면 생성해야 한다. Client: Flyweight 에 대한 참조자를 관리하고 Flyweight 의 부가적 상태를 저장한다.7. Proxy 다른 객체로의 접근을 통제하기 위해서 다른 객체의 대리자 또는 다른 객체로의 정보 보유자를 제공한다.7.1 구조7.2 설명 Proxy: 실제로 참조할 대상에 대한 참조자를 관리한다. Subject 와 동일한 인터페이스를 제공하여 실제 대상을 대체할 수 있어야 한다. 실제 대상에 대한 접근을 제어하고 실제 대상의 생성과 삭제를 책임진다. Subject: RealSubject 와 Proxy 에 공통적인 인터페이스를 정의하고 있어, RealSubject 가 요청되는 곳에 Proxy 를 사용할 수 있게 한다. RealSubject: 프록시가 대표하는 실제 객체이다.7.3 Proxy 종류 종류 설명 원격지 프록시 서로 다른 주소 공간에 존재하는 개체에 대한 지역적 표현으로 사용된다. 요청 메시지와 Argument를 인코딩하여 이를 다른 주소 공간에 있는 실제 대상에게 전달한다. 가상 프록시 요청이 있을 때만 필요한 객체를 생성한다. 실제 대상에 대한 추가적 정보를 보유하고 있어 실제 접근을 지연할 수 있도록 한다. 보호용 프록시 원래 객체에 대한 실제 접근을 제어한다. 객체별로 접근 제어 권한이 다를 때, 유용하게 사용할 수 있다. " }, { "title": "1. Design Pattern 생성패턴", "url": "/posts/Chap1-DesignPattern-%EC%83%9D%EC%84%B1/", "categories": "Design Pattern, Chapter 1(생성패턴)", "tags": "Design Pattern", "date": "2022-04-24 11:00:00 +0900", "snippet": "1 Abstract Factory 구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공한다.1.1 구조1.2 설명 AbstractFactory: 개념적 제품에 대한 객체를 생성하는 오퍼레이션으로 인터페이스를 정의한다. ConoreateFactory: 구제척인 제품에 대한 객체를 생성하는 오퍼레이션을 구현한다. AbstractProduct: 개념적 제품 객체에 대한 인터페이스를 정의한다. ConcreateProduct: 구체적으로 팩토리가 생성할 객체를 정의하고, AbstractProduct 가 정의하고 있는 인터페이스를 구현한다. Client: AbstractFactory 와 AbstractProduct 클래스에 선언된 인터페이스를 사용한다.2 Builder 복합 객체의 생성 과정과 표현 방법을 분리함으로써 동일한 생성 공정이 서로 다른 표현을 만들 수 있게 한다.2.1 구조2.2 설명 Builder: Product 객체의 일부 요소들을 생성하기 위한 추상 인터페이스를 정의한다. ConcreateBuilder: Builder 클래스에 정의된 인터페이스를 구현하며, 제품의 부품들을 모아 빌더를 합성한다. 생성한 요소의 표현을 정의하고 관리한다. 또한 제품을 검색하는데 필요한 인터페이스를 제공한다. Director: Builder 인터페이스를 사용하는 객체를 합성한다. Product: 구축할 복합 객체를 표현한다. ConcreateBuilder 는 제품의 내부 표현을 구축하고 어떻게 모아 하나로 만드는지의 과정을 정의한다.3 Factory Method 객체를 생성하는 인터페이스를 정의하지만, 인스턴스를 만들 클래스의 결정은 서브클래스가 한다. Factory Method 패턴에서는 클래스의 인스턴스를 만드는 시점을 서비클래스로 미룬다.3.1 구조3.2 설명 Product: 팩토리 메소드가 생성하는 객체의 인터페이스를 정의한다. ConcreteProduct: Product 클래스에 정의된 인터페이스를 실제로 구현한다. Creator: Product 타입의 객체를 반환하는 팩토리 메소드를 선언한다. Creator 클래스는 팩토리 메소드를 기본적으로 구현하는데, 이 구현에서는 ConcreteProduct 객체를 반환한다. 또한 Product 객체의 생성을 위해 팩토리 메소드를 호출한다. ConcreteCreator: ConcreteProduct 의 인스턴스를 반환하기 위해 팩토리 메소드를 재정의한다.4 Prototype 프로토타입의 인스턴스를 이용해서 생성할 객체의 종류를 명세하고 이 프로토타입을 복사해서 새로운 객체를 생성한다.4.1 구조4.2 설명 Prototype: 자신을 복제하는데 필요한 인터페이스를 정의한다. ConcretePrototype: 자신을 복제하는 오퍼레이션을 구현한다. Client: prototype 에 복제를 요청함으로써 새로운 객체를 생성한다.5 Singleton 클래스의 인스턴스는 오직 하나임을 보장하며 이 인스턴스에 접근할 수 있는 방법을 제공한다.5.1 구조5.2 설명 Singleton: Instance() 오퍼레이션을 정의하여, 유일한 인스턴스로의 접근이 가능하도록 한다. Instance() 오퍼레이션은 클래스 오퍼레이션이다. 클래스 오퍼레이션이란 C++ 에서는 static 으로 정의되는 멤버함수로 클래스에서 만드는 모든 인스턴스에 걸쳐서 공유하는 함수이다. 이로써 유일한 인스턴스의 생성에 대한 책임을 지게 된다." }, { "title": "1. Design Pattern Summary", "url": "/posts/Chap0-DesignPattern-Summary/", "categories": "Design Pattern, Chapter 0(Summary)", "tags": "Design Pattern", "date": "2022-04-24 11:00:00 +0900", "snippet": "디자인 패턴(Design Pattern) 이란? 프로그래밍 할 때, 문제를 해결하고자 코드의 구조들을 일정한 형태로 만들어 재이용하기 편리하게 만든 일정한 패턴이다.디자인 패턴 사용의 장/단점장점 개발자 간의 원활한 의사소통이 가능하다. S/W 구조 파악이 용이하다. 재사용을 통해 개발 시간을 단축할 수 있다. 설계 변경에 대해 유연하게 대처할 수 있다.단점 객체지향 설계/구현 위주로 사용된다. 초기에 투자 비용이 많이든다.디자인 패턴의 종류1. 생성패턴 객체의 생성과 관련된 패턴 종류 설명 Abstract Factory 동일한 주제의 다른 팩토리를 묶어서 생성한다. Builder 생성과 표기를 분리해서 복잡한 객체를 생성한다. Factory Method 생성할 객체의 클래스를 국한하지 않고 객체를 생성한다. Prototype 기존 객체를 복제함으로써 객체를 생성한다. Singleton 한 클래스에 한 객체만 존재하도록 제한한다. 2. 구조패턴 클래스나 객체들을 상속이나 합성하여 더 큰 구조로 만들 수 있게 해주는 패턴 종류 설명 Adapter Interface가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 Interface를 기존 Interface에 덧씌운다. Bridge 추상화와 구현을 분리해 둘을 각각 따로 발전시킬 수 있다. Composite 0, 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용할 수 있다. Decorator 기존 객체의 메서드에 새로운 행동을 추가하거나 오버라이드할 수 있다. Facade 많은 분량의 코드에 접근할 수 있는 단순한 Interface를 제공한다. Flyweight 다수의 유사한 객체를 생성, 조작하는 비용을 절감할 수 있다. Proxy 접근 조절, 비용 절감, 복잡도 감소를 위해 접근이 힘든 객체에 대한 대역을 제공한다. 3. 행위패턴 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴 종류 설명 Chain of Responsibility 책임들이 연결되어 있어 내가 책임을 못 질 것 같으면 다음 책임자에게 자동으로 넘어가는 구조 Command 명령어를 각각 구현하는 것보다는 하나의 추상 클래스에 메서드를 하나 만들고 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행하는 구조 Interpreter 문법 규칙을 클래스화한 구조를 갖는 SQL언어나 통신 프로토콜 같은 류의 개발시 사용하는 패턴 Iterator 반복이 필요한 자료구조를 모두 동일한 Interface를 통해 접근할 수 있도록 메서드를 이용해 자료구조를 활용할 수 있도록 해준다. Mediator 클래스간의 복잡한 상호작용을 캡슐화하여 한 클래스에 위임해서 처리하는 디자인 패턴 Memento undo 기능을 개발할 때, 융용한 디자인 패턴 Observer 특정 클래스에 변화가 일어났을 때, 이를 감지하여 다른클래스에 통보해주는 구조 State 동일한 동작을 객체의 상태에 따라 다르게 처리해야 할 때 사용하는 디저인 패턴 Strategy 알고리즘 군을 정의하고 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용하는 디자인 패턴 Template Method 상위 클래스에서는 추상적으로 표현하고 그 구체적인 내용은 하위 클래서에서 결정되는 디자인 패턴 Visitor 각 클래스의 데이터 구조로부터 처리 기능을 분리하여 별도의 visitor 클래스로 만들어놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 하는 패턴 " }, { "title": "4. Container File 설정", "url": "/posts/Chap3-Container_File/", "categories": "Docker, Chapter 3(컨테이터)", "tags": "Docker Container 파일 설정", "date": "2022-04-19 22:00:00 +0900", "snippet": "0. Summary## 컨테이너로부터 이미지 생성&gt; docker container run -it --name c1 centos&gt; docker container commit c1 centos:hello## 컨테이너를 tar 파일로 출력&gt; docker attach c1# echo \"This is export test\" &gt; export.txt# cat export.txt&gt; docker container export -o ./testexport.tar c1&gt; tar tf testexport.tar | findstr export.txt## 아카이브 파일로 이미지 만들기&gt; docker image import testexport.tar export:test## 이미지 저장&gt; docker image save -o imgarc.tar centos&gt; attrib imgarc.tar## 이미지 불러오기&gt; docker image load -i imgarc.tar## 컨테이너 파일 복사&gt; docker container cp dockercp.txt c1:/&gt; docker container exec -it c1 cat /dockercp.txt## 컨테이너 파일 변경 확인&gt; docker container diff c11. Container로 부터 이미지 작성docker container commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] docker contaienr commit 명령을 사용하여 Container를 새오루 이미지로 생성할 수 있다.&gt; docker container commit --helpUsage: docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]Create a new image from a container's changesOptions: -a, --author string Author (e.g., \"John Hannibal Smith \") -c, --change list Apply Dockerfile instruction to the created image -m, --message string Commit message -p, --pause Pause container during commit (default true) repository와 tag를 지정하지 않으면 Dangle Image가 생성된다. (권장 x) ex&gt; c1이미지를 생성한다. &gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7ab5c4764a79 centos \"/bin/bash\" 5 hours ago Up 5 hours c1&gt; docker container commit c1sha256:cde75dbdf4f46bfc6cc31efcf4034d0577ef3218c9f9b48d2bc28250813d7c12&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZE cde75dbdf4f4 4 seconds ago 200MB ex&gt; c1 이미지를 centos:hello라는 이름의 이미지로 생성한다.&gt; docker container commit c1 centos:hellosha256:8e371c761123fdb3646356e5336ff174bbba2ba86971d038b75f155e989d0350&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos hello 8e371c761123 6 seconds ago 200MB cde75dbdf4f4 About a minute ago 200MB2. Container를 tar 파일로 출력docker container export [OPTION] CONTAINER ex&gt; c1 Container를 생성하고 텍스트 파일을 생성한 뒤 docker export 명령을 실행한다. 아카이브 파일 중에 Container에 생성한 export.txt 파일이 존재한다. &gt; cd C:\\Users\\UserName\\temp&gt; docker container run -it --name c1 centos# echo \"This is export test\" &gt; export.txt# cat export.txtThis is export test[Ctrl + P + Q]&gt; docker container export -o testexport.tar c1&gt; tar tf testexport.tar | findstr export.txtexport.txt3. 아카이브 파일로 이미지 만들기docker image import [OPTIONS] file|URL|- [REPOSITORY[:TAG]] ex&gt; 위에서 생성한 testexport.tar 파일로 이미지를 생성한다.&gt; cd C:\\Users\\UserName\\temp&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEhttpd latest 0240c8f5816c 2 days ago 132MBcentos latest 75835a67d134 12 days ago 200MBhello-world latest 4ab4c602aa5e 6 weeks ago 1.84kB&gt; docker image import testexport.tar export:testsha256:fc31567e00eb5422899e8405d82d2e909de6f24bbe71effae9a4dda12aebbf55&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEexport test fc31567e00eb 5 seconds ago 200MBhttpd latest 0240c8f5816c 2 days ago 132MBcentos latest 75835a67d134 12 days ago 200MBhello-world latest 4ab4c602aa5e 6 weeks ago 1.84kB4. 이미지 저장docker image save [OPTIONS] IMAGE [IMAGE...] docker save 명령으로 이미지를 아카이브로 저장할 때 반드시 -o 옵션을 사용하여 경로를 지정한다. ex&gt; centos hello-world httpd 이미지를 아카이브 파일로 저장한다.&gt; cd C:\\Users\\UserName\\temp&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEhttpd latest 0240c8f5816c 2 days ago 132MBcentos latest 75835a67d134 12 days ago 200MBhello-world latest 4ab4c602aa5e 6 weeks ago 1.84kB&gt; docker image save -o imgarc.tar centos&gt; attrib imgarc.tarA C:\\Users\\UserName\\imgarc.tar5. 이미지 불러오기docker image load [OPTIONS] docker save 명령으로 저장한 아카이브 파일을 불러올 수 있다. docker load 명령으로 이미지를 불러올 때 반드시 -i 옵션을 사용하여 경로를 지정한다. ex&gt; imgarc.tar 파일을 로드한다.&gt; cd C:\\Users\\UserName\\temp&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 75835a67d134 12 days ago 200MB&gt; attrib imgarc.tarimgarc.tar: POSIX tar archive&gt; docker image load -i imgarc.tarLoaded image: centos:latest428c97da766c: Loading layer 3.584kB/3.584kBLoaded image: hello-world:latest237472299760: Loading layer 58.44MB/58.44MB504b6a6a6fd2: Loading layer 2.56kB/2.56kB355bd981febe: Loading layer 34.57MB/34.57MB0ace1cc25781: Loading layer 43.58MB/43.58MB7857c7afb135: Loading layer 3.584kB/3.584kBLoaded image: httpd:latest&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEhttpd latest 0240c8f5816c 2 days ago 132MBcentos latest 75835a67d134 12 days ago 200MBhello-world latest 4ab4c602aa5e 6 weeks ago 1.84kB(export/import) 와 (save/load)의 차이 Command 결과 사용처 소스 export tar File Container File System Container import Docker Image Flat File System tar File save tar File Docker Image Image load Docker Image Docker Image tar File Flat File System: 하위 디렉토리 없이 파일들을 포함하는 하나의 디렉토리 export와 import는 플랫 파일 시스템에서 동작한다. export는 Container 상태를 구성하는 tar파일을 생성한다. Docker와 마찬가지로 프로세스 실행 상태는 저장되지 않는다. 즉, 파일만 저장한다. import는 tar파일에서 히스토리 or 메타 데이터가 없는 docker image를 생성한다.6. Container 파일 복사Host -&gt; Container: docker container cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-Container -&gt; Host: docker container cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH ex&gt; host에 있는 dockercp.txt 파일을 c1 Container로 복사한다.&gt; docker container run -itd --name c1 centose9b448f07d99af238fd6dfb050d761ed423b9f0996abb4eae00658d20f749cf2&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe9b448f07d99 centos \"/bin/bash\" 3 seconds ago Up 2 seconds c1&gt; docker container cp dockercp.txt c1:/&gt; docker container exec -it c1 cat /dockercp.txtThis is \"docker cp\" Test ex&gt; c1 Container에 있는 dockercp.txt파일을 host로 복사한다.&gt; docker cp c1:/dockercp.txt .&gt; cat dockercp.txtThis is \"docker cp\" Test7. Container 파일 변경 확인docker container diff CONTAINER 구분 설명 A 파일 추가 D 파일 삭제 C 파일 수정 ex&gt; webserver 이름의 Container에서 Container 조작 변경을 확인한다.&gt; docker container diff webserverC /usrC /usr/localC /usr/local/apache2C /usr/local/apache2/logsA /usr/local/apache2/logs/httpd.pid ex&gt; centos 이미지를 c1으로 Container화 한 뒤 dira/filea.txt파일 생성 뒤 anaconda-post.log를 삭제한다.&gt; docker container run -it --name c1 centos# mkdir dira# echo \"This is filea\" &gt; dira/filea.txt# lsanaconda-post.log dev etc lib media opt root sbin sys usrbin dira home lib64 mnt proc run srv tmp var# rm -f anaconda-post.log[Ctrl + P + Q]&gt; docker container diff c1A /diraA /dira/filea.txtD /anaconda-post.log" }, { "title": "3. Container 환경 및 네트워크", "url": "/posts/Chap3-Container_EnvAndNetwork/", "categories": "Docker, Chapter 3(컨테이터)", "tags": "Docker Container 환경 및 네트워크", "date": "2022-04-17 22:00:00 +0900", "snippet": "Summary## 컨테이너 환경변수 설정&gt; docker container run -d -e MYSQL_ROOT_PASSWORD=1234 --name db1 mysql## 네트워크 목록 표시&gt; docker network ls## 네트워크 상세 정보 확인&gt; docker network inspect bridge## 네트워크 생성&gt; docker network create --driver=bridge d-net&gt; docker network create --subnet 192.168.0.0/24 --gateway 192.168.0.254 customnet## 네트워크 연결&gt; docker container run -it --name a1 alpine&gt; docker attach a1/ # ifconfig&gt; docker network connect customnet a1&gt; docker attach a1/ # ifconfig&gt; docker container run -it --net customnet --name a1 alpine&gt; docker network disconnect customnet a1## 네트워크 삭제&gt; docker network rm d-net## 컨테이너 링크&gt; docker container run -itd --name a1 alpine&gt; docker container run -itd --name a2 --link a1 alpine&gt; docker attach a2/ # ping -c1 a1&gt; docker attach a1/ # ping -c1 a2## 외부에서 컨테이너 접속&gt; docker container run -d -p 80:80 --name web2 httpd&gt; docker container ps&gt; curl localhost1. Container 환경 변수 설정docker container run -e docker container run 명령의 -e 옵션을 사용하여 Container 내부에 환경 변수를 설정할 수 있다. 보통 설정 값이나 비밀번호를 전달할 때 사용한다. ex&gt; centos Container를 a=100, b20, c=30으로 환경 변수를 설정한다.&gt; docker container run -it -e a=100 --name c1 centos# echo $a100[Ctrl + P + Q]&gt; docker container run -it -e b=20 -e c=30 centos# echo $b20# echo $c30 ex&gt; mysql 이미지를 사용하여 Container를 생성한다. 포그라운드로 실행해야한다. 메시지는 표준 에러로 출력되며, 몇몇 환경 변수를 설정해야 한다는 문구가 나온다. &gt; docker container run -it --name db1 mysqlerror: database is uninitialized and password option is not specified You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD ex&gt; mysql 이미지를 자세히 확인한다. 보통 이미지가 실행되면 cmd에 지정된 어플리케이션이 실행된다. Entrypoint가 지정되어 있으면 Entrypoint가 cmd보다 우선적으로 실행된다. Entrypoint는 쉘 스크립트로 이루어져 있으며 Container가 실행되기 위한 조건을 확인하고 일치하지 않으면 Container를 실행하지 않거나 특정 작업을 수행한다. &gt; docker image inspect mysql... &lt;생략&gt;... \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"GOSU_VERSION=1.7\", \"MYSQL_MAJOR=8.0\", \"MYSQL_VERSION=8.0.12-1debian9\" ], \"Cmd\": [ \"/bin/sh\", \"-c\", \"#(nop) \", \"CMD [\\\"mysqld\\\"]\" ],... &lt;생략&gt;... \"Entrypoint\": [ \"docker-entrypoint.sh\" ],... &lt;생략&gt;... 환경변수를 MYSQL_ROOT_PASSWORD=1234로 지정한다. &gt; docker container run -d -e MYSQL_ROOT_PASSWORD=1234 --name db1 mysql 65dcb4a71896ae110ef0cc89f9e6d7ba00f9e78846ede9c169b228d1369aadb6 &gt; docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 65dcb4a71896 mysql \"docker-entrypoint.s…\" 3 seconds ago Up 2 seconds 3306/tcp, 33060/tcp db12. Conainer Network 관리도커 네트워크란? Container로서 실행중인 mysql server에 접근하기 위해서는 Container 실행 시, --link 옵션을 이용해 Container 간의 연결이 필요하다. 같은 Docker Host내에서 실행 중인 Container간 연결할 수 있도록 돕는 네트워크다.Container 네트워크 구조 만약 외부와 연결을 해야할 경우에는 호스트에 veth(=virtual eth)라는 네트워크 인터페이스를 생성하고 컨테이너의 eth와 연결이 된다. veth 인터페이스는 사용자가 직접 생성할 필요 없이 도커엔진에 의해 자동으로 생성된다. veth 인터페이스 뿐만 아니라 docker()라는 브리지도 있는데 이는 veth 인터페이스와 바인딩되어 호스트의 eth 인터페이스와 연결을 해준다.네트워크 유형bridge docker() bridge와 비슷하지만 사용자가 정의한 브리지를 생성해 각 컨테이너에 연결하는 네트워크 구조로 컨테이너는 연결된 브리지를 통해 외부와 통신할 수 있다. 보통 컨테이너가 사용하는 네트워크를 추가로 생성할 때에는 bridge 네트워크를 생성한다. 네트워크 생성 시 별도의 드라이버(bridge, host, none 등)을 지정하지 않으면 기본 값으로 생성되는 네트워크이다. ex&gt; customnet 네트워크로 컨테이너를 생성한 뒤 네트워크를 확인한다.&gt; docker container run -it --net customnet --name a1 alpine/ # ifconfigeth0 Link encap:Ethernet HWaddr 02:42:C0:A8:00:01 inet addr:192.168.0.1 Bcast:192.168.0.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:15 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:1580 (1.5 KiB) TX bytes:0 (0.0 B)host host 유형의 네트워크는 호스트의 네트워크를 공유한다. Container 내부의 어플리케이션을 별도의 포트 포워딩 없이 바로 서비스할 수 있다. ex&gt; host 네트워크로 Container를 생성한 뒤 네트워크를 확인한다.&gt; docker container run -it --net host --name a2 alpine/ # ifconfig...&lt;생략&gt;eth0 Link encap:Ethernet HWaddr 08:00:27:D1:E8:E8 inet addr:10.0.2.15 Bcast:10.0.2.255 Mask:255.255.255.0 inet6 addr: fe80::82db:bc1f:34fb:7c50/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:200313 errors:0 dropped:0 overruns:0 frame:0 TX packets:49657 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:226258165 (215.7 MiB) TX bytes:3151008 (3.0 MiB)...&lt;생략&gt;none Container에 어떤 네트워크도 할당하지 않는다. 외부와 단절된다. ex&gt; none 네터워크로 Container를 생성한 뒤 네트워크를 확인한다.&gt; docker container run -it --name a1 --net none alpine/ # ifconfiglo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B)네트워크 관리docker network COMMAND docker에서 Container 네터워크를 관리하려면 docker network명령을 사용한다.&gt; docker network --helpUsage: docker network COMMANDManage networksCommands: connect Connect a container to a network create Create a network disconnect Disconnect a container from a network inspect Display detailed information on one or more networks ls List networks prune Remove all unused networks rm Remove one or more networksRun 'docker network COMMAND --help' for more information on a command.네트워크 목록 표시docker network ls docker의 네트워크는 bridge, host, none 세 종류가 있다.&gt; docker network lsNETWORK ID NAME DRIVER SCOPE948486320b16 bridge bridge local9997deede5a1 host host local48be711d1ba7 none null local네트워크 상세 정보 확인docker network inspect [OPTIONS] NAME | ID [NAME|ID...] 네트워크의 상세 정보를 확인하려면 docker network inspect 명령을 사용한다.&gt; docker network inspect --helpUsage: docker network inspect [OPTIONS] NAME|ID [NAME|ID...]Return low-level information on Docker objectsOptions: -f, --format string Format the output using the given Go template -s, --size Display total file sizes if the type is container --type string Return JSON for specified type ex&gt; 기본적으로 존재하는 bridge 네트워크를 확인한다.&gt; docker network inspect bridge[ { \"Name\": \"bridge\", \"Id\": \"eb2a64dc0eb56235d3b09b16b91f3b1987b43dc91f49bdf7f0cf2340b033f30d\", \"Created\": \"2018-10-22T14:22:06.68394493+09:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": null, \"Config\": [ { \"Subnet\": \"172.17.0.0/16\" } ] },... &lt;생략&gt; \"com.docker.network.bridge.name\": \"docker0\", \"com.docker.network.driver.mtu\": \"1500\" }, \"Labels\": {} }]네트워크 생성docker network create [OPTIONS] NETWORK docker network create 명령을 사용하면 도커 네트워크를 생성할 수 있다.&gt; docker network create --helpUsage: docker network create [OPTIONS] NETWORKCreate a networkOptions: --attachable Enable manual container attachment --aux-address map Auxiliary IPv4 or IPv6 addresses used by Network driver (default map[]) --config-from string The network from which copying the configuration --config-only Create a configuration only network -d, --driver string Driver to manage the Network (default \"bridge\") --gateway strings IPv4 or IPv6 Gateway for the master subnet --ingress Create swarm routing-mesh network --internal Restrict external access to the network --ip-range strings Allocate container ip from a sub-range --ipam-driver string IP Address Management Driver (default \"default\") --ipam-opt map Set IPAM driver specific options (default map[]) --ipv6 Enable IPv6 networking --label list Set metadata on a network -o, --opt map Set driver specific options (default map[]) --scope string Control the network's scope --subnet strings Subnet in CIDR format that represents a network segment 네트워크 생성 시 별도의 드라이버(bridge, host, none..)을 지정하지 않으면 기본 값으로 생성되는 네트워크는 bridge이다. ex&gt; dlfmadl d-net인 bridge 유형의 도커 네트워크를 생성한다. 네터워크 범위는 자동으로 172.18.0.0/16으로 설정된다. –drive 옵션에서 지정할 수 있는 네터워크 드라이버는 bridge or overlay이다. overlay 네트워크는 여러 개의 호스트에 걸쳐 있는 네트워크이다. &gt; docker network create --driver=bridge d-netd9c9fe157e6d173e3609e8bac426ec52aeda330ead3996641e17dc525c545f7d&gt; docker network lsNETWORK ID NAME DRIVER SCOPEeb2a64dc0eb5 bridge bridge locald9c9fe157e6d d-net bridge local4395a69bc04c host host local8d28eb905273 none null local&gt; docker network inspect d-net...&lt;생략&gt;... \"Subnet\": \"172.18.0.0/16\", \"Gateway\": \"172.18.0.1\"...&lt;생략&gt;... 네트워크 범위를 설정하려면 --subnet옵션을 사용하며 게이트웨이는 --gateway 옵션을 사용한다. ex&gt; subnet이 192.168.0.0/24이고 gateway가 192.168.0.254인 customnet 이름의 네트워크를 생성한다. &gt; docker network create --subnet 192.168.0.0/24 --gateway 192.168.0.254 customnet63f54042c3b8e72f145847d16f8b94ab46cb2e23b1f19b9ac7f4806f4b3bd7a3&gt; docker network lsNETWORK ID NAME DRIVER SCOPEeb2a64dc0eb5 bridge bridge local63f54042c3b8 customnet bridge locald9c9fe157e6d d-net bridge local4395a69bc04c host host local8d28eb905273 none null local&gt; docker network inspect customnet... &lt;생략&gt; \"Subnet\": \"192.168.0.0/24\", \"Gateway\": \"192.168.0.254\"... &lt;생략&gt;네트워크 연결docker network connect [OPTIONS] NETWORK CONTAINER ex&gt; a1 Conainer에 customnet 네트워크를 연결 시킨다.&gt; docker container run -it --name a1 alpineUnable to find image 'alpine:latest' locallylatest: Pulling from library/alpinee7c96db7181b: Pull completeDigest: sha256:769fddc7cc2f0a1c35abb2f91432e8beecf83916c421420e6a6da9f8975464b6Status: Downloaded newer image for alpine:latest/ #&gt; docker attach a1/ # ifconfigeth0 Link encap:Ethernet HWaddr 02:42:AC:11:00:03 inet addr:172.17.0.3 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:9 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:718 (718.0 B) TX bytes:0 (0.0 B)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B) / # read escape sequence&gt; docker network connect customnet a1&gt; docker attach a1/ # ifconfigeth0 Link encap:Ethernet HWaddr 02:42:AC:11:00:03 inet addr:172.17.0.3 Bcast:172.17.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:12 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:928 (928.0 B) TX bytes:0 (0.0 B)eth1 Link encap:Ethernet HWaddr 02:42:C0:A8:00:01 inet addr:192.168.0.1 Bcast:192.168.0.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:9 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:758 (758.0 B) TX bytes:0 (0.0 B)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:0 errors:0 dropped:0 overruns:0 frame:0 TX packets:0 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1 RX bytes:0 (0.0 B) TX bytes:0 (0.0 B)/ # 사용자가 생성한 네트워크를 Container가 사용하려면 docker container run 명령의 --net 옵션을 사용한다. ex&gt; alpine 이미지를 a1으로 Container화를 하고, 사용자가 생성한 customnet 네트워크를 Container가 사용한다. &gt; docker container run -it --net customnet --name a1 alpine 네트워크에 대한 연결을 해제할 때는 docker network disconnect 명령을 사용한다. ex&gt; a1 Container에 customnet 네트워크 연결을 해제한다. &gt; docker network disconnect customnet a1네트워크 삭제docker network rm NETWORK [NETWORK...] ex&gt; web-network 를 삭제한다.&gt; docker network rm web-networkweb-network3. Contaienr 통신 docker는 Container를 연결시켜주는 링크 기능과 호스트 외부에서 접근할 수 있도록 포트 포워딩을 사용할 수 있다.Container Link Container는 IP를 동적으로 받아오기 때문에 항상 일치하지 않는다. 이는 서로 다른 두 개의 Container를 연결해서 사용할 때 문제가 될 수 있다. Linux 시스템 또는 Container는 다른 시스템이나 Container와 통신할 때 IP기반으로 하기 때문이다. 이 때 Container의 IP가 동적으로 변경되어도 통신이 유지되도록 하는 기능이 Container Link이다.Container 연동시 link를 사용해야 하는 이유 동일 host상에 배포된 Container사이에는 Private IP를 이용해 통신이 가능하다. ex&gt; 동일 host상에 running중인 두 개의 Containe이다.CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESca7f026ff0ad httpd \"httpd-foreground\" 55 minutes ago Up 55 minutes 0.0.0.0:80-&gt;80/tcp web0117b6c5f037a9 mysql \"docker-entrypoint.sh\" About an hour ago Up 50 minutes 0.0.0.0:3306-&gt;3306/tcp mysql ex&gt; 두 Container mysql과 web01의 Private IP는 아래와 같다.&gt; docker inspect -f \"\" mysql172.17.0.6&gt; docker inspect -f \"\" web01172.17.0.3 ex&gt; 만약, web01 –&gt; mysql(172.17.0.6)로 IP를 기반으로 ping을 보내면 아래와 같이 응답함을 볼 수 있다.&gt; docker exec -t web01 ping 172.17.0.6PING 172.17.0.6 (172.17.0.6): 56 data bytes64 bytes from 172.17.0.6: icmp_seq=0 ttl=64 time=0.103 ms64 bytes from 172.17.0.6: icmp_seq=1 ttl=64 time=0.117 ms64 bytes from 172.17.0.6: icmp_seq=2 ttl=64 time=0.111 ms64 bytes from 172.17.0.6: icmp_seq=3 ttl=64 time=0.114 ms64 bytes from 172.17.0.6: icmp_seq=4 ttl=64 time=0.111 ms64 bytes from 172.17.0.6: icmp_seq=5 ttl=64 time=0.116 ms... 하지만, Container 사이의 IP 기반 연동은 문제점을 안고 있다. Container의 IP는 언제든 변할 수 있는 유동적인 성격을 띄고 있기 때문이다. Container는 일종의 Process이므로, 언제든 생성/소멸 될 수 있음을 전제로 해야한다. 만약 Container가 중지 되었다가 시작하면, Process가 kill되었다가 다시 새롭게 생성되는 것과 같다. 이때, Container에게 부여되는 Private IP는 언제든 별할 수 있다. 따라서, Container 사이 연동을 하려면, IP 기반의 설정은 권고되지 않는다. 그 해결 방법으로 권고 되고 있는 방법이 바로 link 옵션이다.run --link 서로 다른 두 개의 Container를 LINK로 연결하려면 docker container run 명령에 --link 옵션을 사용한다. ex&gt; a1과 a2 Container를 생성한 뒤에 a2가 a1에 링크되도록 한다. a2는 a1이라는 이름으로 통신이 가능하지만 a1은 a2라는 이름으로 통실할 수 없다. &gt; docker run -itd --name a1 alpine1cca39d03936a80ab9917c50b1c87a68d273fa41998c89034084de6ce324aa9b&gt; docker run -itd --name a2 --link a1 alpine46c3ed8634c6202d78970354211b07d50198b1642be300758d1b1e46162f2af2&gt; docker attach a2/ # ping -c1 a1PING a1 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.131 ms--- a1 ping statistics ---1 packets transmitted, 1 packets received, 0% packet lossround-trip min/avg/max = 0.131/0.131/0.131 ms&gt; docker attach a1/ # ping -c1 a2ping: bad address 'a2' Container를 실행할 때, --link옵션을 사용하면 Container의 /etx/hosts 파일에 기록하기 때문이다.&gt; docker exec a1 cat /etc/hosts...&lt;생략&gt;...172.17.0.2 1cca39d03936&gt; docker exec a2 cat /etc/hosts...&lt;생략&gt;...172.17.0.2 a1 1cca39d03936172.17.0.3 46c3ed8634c6 :을 사용하여 별칭도 등록할 수 있다. alpine1으로 별칭을 등록한다.&gt; docker container run -itd --name a1 alpine2bb5c8c798c93cbb5da86f10dcae8a9c17f4cf4f811bc6915604f380997b1c76&gt; docker run -itd --name a2 --link a1:alpine1 alpine444775da89922c05a20d57b6a10c6741a3e3f9a1af4a4f2fe9e0a6bcf996de2f&gt; docker container exec a2 ping -c1 alpine1PING alpine1 (172.17.0.2): 56 data bytes64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.177 ms--- alpine1 ping statistics ---1 packets transmitted, 1 packets received, 0% packet lossround-trip min/avg/max = 0.177/0.177/0.177 ms&gt; docker container exec a2 cat /etc/hosts...&lt;생략&gt;172.17.0.2 alpine1 2bb5c8c798c9 a1172.17.0.3 444775da8992link 방식의 한계 link옵션을 동일 docker host에 존재하는 Container 사이에서만 유효하다. 만약 다수의 docker host를 운영할 경우에 타 host에 상주하는 Container 사이에는 link 옵션 사용이 불가하다. Container의 hosts 파일의 관리를 docker host가 직접 수행하기 때문이다. 이러한 경우, docker swarm 같은 orchestration 툴을 도입하거나 dynamic DNS를 구축해 사용해야 한다." }, { "title": "2. Container 조작", "url": "/posts/Chap3-Container_Controll/", "categories": "Docker, Chapter 3(컨테이터)", "tags": "Docker Container Controll", "date": "2022-04-13 22:00:00 +0900", "snippet": "0. Summary## 컨테이너 접근&gt; docker container attach webserver## 컨테이너에서 어플리케이션 실행&gt; docker container exec -it webserver /bin/echo \"Hello world\"## 컨테이너에서 실행 중인 프로세스 확인&gt; docker container top webserver## 컨테이너 이름 변경&gt; docker container rename webserver s1## 컨테이너 로그 확인&gt; docker container logs s1## 컨테이너 차분 확인&gt; docker container diff s11. Container attach (컨테이너 접근)docker container attach [OPTIONS] CONTAINER 백그라운드에서 실행 중인 Container에 접근하려면 docker attach 명령을 사용한다.&gt; docker container attach --helpUsage: docker container attach [OPTIONS] CONTAINERAttach local standard input, output, and error streams to a running containerOptions: --detach-keys string Override the key sequence for detaching a container --no-stdin Do not attach STDIN --sig-proxy Proxy all received signals to the process (default true) ex&gt; centos 이미지를 c1이름으로 실행 시킨 후 attach 명령으로 다시 접근한다. 연결한 Container를 종료하려면 ctrl + c, Container를 시작한 채로 Container 안에서 움직이는 프로세스만 종료하려면 ctrl + p + q를 입력한다. &gt; docker container run -itd --name c1 centos5e0ebf558f47092da3e1c2cc3cb59d91b41256eceb892412e8deb7cbcb2f11f6&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES5e0ebf558f47 centos \"/bin/bash\" 3 seconds ago Up 3 seconds c1&gt; docker container attach c1# read escape sequence2. Container exec(컨테이너에서 어플리케이션 실행)docker container exec [OPTIONS] CONTAINER COMMAND [ARG...] 가동 중인 Container에서 새로운 프로세스를 작성할 때는 docker container exec 명령을 사용한다.&gt; docker container exec --helpUsage: docker contianer exec [OPTIONS] CONTAINER COMMAND [ARG...]Run a command in a running containerOptions: -d, --detach Detached mode: run command in the background --detach-keys string Override the key sequence for detaching a container -e, --env list Set environment variables -i, --interactive Keep STDIN open even if not attached --privileged Give extended privileges to the command -t, --tty Allocate a pseudo-TTY -u, --user string Username or UID (format: [:]) COMMAND: 실행할 어플리케이션의 경로를 지정하며, 경로에 따라 아규먼트를 지정한다. 실행 중인 Container에서만 실행할 수 있다. ex&gt; 실행 중인 web1 Container에 추가로 bash 쉘을 실행한다. bash만 종료 =&gt; exit 명령으로 Container를 빠져나와도 web1 Container는 종료되지 않는다. &gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1e220a23ba2e httpd \"httpd-foreground\" 2 minutes ago Up 2 minutes 80/tcp web1&gt; docker container exec -it web1 bash# exitexit&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1e220a23ba2e httpd \"httpd-foreground\" 2 minutes ago Up 2 minutes 80/tcp web1 명령을 직접 실행할 수 있다. ex&gt; webserver 라는 이름의 Container에서 echo명령을 실행한다. &gt; docker container exec -it webserver /bin/echo \"Hello world\"Hello world3. Container top(컨테이너 내의 실행 중인 프로세스 확인)docker container top CONTAINER [ps OPTION] Container에서 실행 중인 프로세스를 확인하려면 docker container top명령을 사용한다.&gt; docker container top --helpUsage: docker container top CONTAINER [ps OPTIONS]Display the running processes of a container ex&gt; webserver Container에서 실행되고 있는 프로세스를 확인한다.&gt; docker container top webserverPID USER TIME COMMAND13055 root 0:00 httpd -DFOREGROUND13103 bin 0:00 httpd -DFOREGROUND13104 bin 0:00 httpd -DFOREGROUND13105 bin 0:00 httpd -DFOREGROUND13215 root 0:00 /bin/bash 4. Container rename(컨테이너 이름 변경)docker container rename CONTAINER NEW_NAME docker container rename 명령을 사용하면 Contaienr의 이름을 변경할 수 있다.&gt; docker container rename --helpUsage: docker rename CONTAINER NEW_NAMERename a container Container를 생성하거나 실행 할 때 –name 옵션을 사용하지 않으면 임의의 이름이 부여된다. ex&gt; centos 이미지를 Container화 할 때 이름 옵션을 사용하지 않고 rename을 이용해 이름을 변경한다. &gt; docker container run -itd centos83d429b77a0dcee42e7c6c9e8883d0c31ad3aa9d51f4d40bdb7e463056eb0648&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES83d429b77a0d centos \"/bin/bash\" 4 seconds ago Up 3 seconds sharp_mahavira&gt; docker container rename sharp_mahavira newc1&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES83d429b77a0d centos \"/bin/bash\" 44 seconds ago Up 43 seconds newc1 Container가 실행 중이 아니어도 사용할 수 있다.5. Container logs(컨테이너 로그 확인)docker container logs [OPTIONS] CONTAINER Container가 실행되다가 갑자기 종료되거나 어플리케이션이 정상적으로 동작하지 않으면 로그를 확인해야 한다. Container의 표준 출력 및 에러를 확인할 수 있다. Container의 로그를 확인하려면 docker container log 명령을 사용한다.&gt; docker container logs --helpUsage: docker container logs [OPTIONS] CONTAINERFetch the logs of a containerOptions: --details Show extra details provided to logs -f, --follow Follow log output --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) --tail string Number of lines to show from the end of the logs (default \"all\") -t, --timestamps Show timestamps --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) ex&gt; db1 Container 의 로그를 확인한다.&gt; docker container logs db1Initializing database2018-10-22T20:49:39.880951Z 0 [Warning] [MY-011070] [Server] 'Disabling symbolic links using --skip-symbolic-links (or equivalent) is the default. Consider not using this option as it' is deprecated and will be removed in a future release.2018-10-22T20:49:39.881078Z 0 [System] [MY-013169] [Server] /usr/sbin/mysqld (mysqld 8.0.12) initializing of server in progress as process 28mbind: Operation not permittedmbind: Operation not permitted...&lt;생략&gt;... Container가 꼭 실행 중이지 않아도 로그를 확인할 수 있다. ex&gt; 중지된 Container의 logs2의 로그를 확인한다. &gt; docker container run -d -e MYSQL_ROOT_PASSWORD=1234 --name logs2 httpdcf5588ebaa22051b798a1e63f6810513fb1beae573838f05e9005853f1144022&gt; docker stop cf5cf5&gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMEScf5588ebaa22 httpd \"httpd-foreground\" 26 seconds ago Exited (0) 2 seconds ago logs2&gt; docker container logs log2AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.2. Set the 'ServerName' directive globally to suppress this ...&lt;생략&gt;...s -t 옵션: 중지된 Container의 로그를 확인할 때 타임 테이블을 표시한다. --tail 옵션: 최근 발생된 로그를 확인하는 옵션이다. --since 옵션: 특정 날짜로부터 로그를 확인하는 옵션이다. docker container logs -t -- since \"2022-04-13T22:30\" logs2 6. Health CheckingContainer 내보의 프로세스가 정상적으로 동작하고 있는지를 확인하는 것CMD 명령 CMD 상태란 Console에서 docker run을 할 때 처럼 Container를 바로 실행할 때 사용하는 명령이다.docker run --health-cmd command CMD 상태에서 처리할 수 있는 옵션 –interval=DURATION(기본값: 30s) –timeout=DURATION(기본값: 30s) –start-period=DURATION(기본값: 0s) –retries=N(기본값: 3) 상태 체크를 하지 않았을 경우 ex&gt; db Container를 실행한다. 5초 전에 Container를 조회하면 health check가 시작되고 있는 모습을 확인할 수 있다.&gt; docker run --rm -d --name health -p 8080:8080 effectivetrainings/docker-health&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES84ba30fd483d effectivetrainings/docker-health \"java -jar /app.jar\" About a minute ago Up About a minute 0.0.0.0:8080-&gt;8080/tcp health ex&gt; curl 명령어을 통해 확인해 본다. 아래의 명령은 url을 실행해 결과 값을 받아오고 오류가 나면 1을 출력하는 예제이다. 정상적으로 출력 값을 받아온다.&gt; curl -s -S -f http://127.0.0.1:8080/health || echo 1{\"status\":\"UP\",\"static\":{\"status\":\"UP\"},\"diskSpace\":{\"status\":\"UP\",\"total\":10340831232,\"free\":6843023360,\"threshold\":10485760}}상태 체크를 한 경우 –health 옵션을 사용해서 healthck 컨테이너를 실행한다. 2초마다 health를 체크한다.&gt; docker run --rm -d --name healthck -p 8080:8080 --health-cmd='curl -f -s -S http://127.0.0.1:8080/health || exit 1' --health-interval=2s effectivetrainings/docker-health0c4192a1b2a3e68019f8de66c1dc8e7049a1b1ae5fa8f6d9a197422d8dd4b965&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES0c4192a1b2a3 effectivetrainings/docker-health \"java -jar /app.jar\" 10 seconds ago Up 9 seconds (healthy) 0.0.0.0:8080-&gt;8080/tcp healthck7. Container 자원 제한 Container를 생성할 때, 다양한 옵션으로 Container Resource 사용량을 조절할 수 있다. 아무 옵션을 입력하지 않으면 기본적으로 Host의 모든 리소스를 제한없이 사용할 수 있다. 이 경우 여러 Container 실행 시 리소스 사용의 불균형이 발생할 수도 있다. 현재 Container에서 설정된 리소스를 확인하는 방법은 docker inspect 명령을 사용한다.&gt; docker container inspect u1... \"HostConfig\": { \"Binds\": null, \"ContainerIDFile\": \"\", \"LogConfig\": { \"Type\": \"json-file\", \"Config\": {} }, \"NetworkMode\": \"default\", ... \"BlkioDeviceWriteIOps\": null, \"CpuPeriod\": 0, \"CpuQuota\": 0, \"CpuRealtimePeriod\": 0, \"CpuRealtimeRuntime\": 0, \"CpusetCpus\": \"\", \"CpusetMems\": \"\", \"Devices\": [], \"DeviceCgroupRules\": null, \"DeviceRequests\": null, \"KernelMemory\": 0, \"KernelMemoryTCP\": 0, ...설정된 자원 변경하기 보통 Container를 생성하는 run, create 명령어에서 자원 할당을 조정할 수 있는데 만들어진 Container의 자원도 아래의 명령어를 통해서 업데이트할 수 있다.&gt; docker update [변경할 자원 제한] [컨테이너 이름]&gt; docker update --cpuset-cpus=1 centos메모리 관리 메모리는 m(Megabyte), g(Gigabyte) 단위로 설정할 수 있으며 최소 메로리는 4mb읻. Container 내부에서 동작하는 프로세스가 Container에 할당된 메모리를 초과하면 자동으로 종료되므로 적절한 메모리를 설정해야 한다. Docker는 Container의 메모리 사용량의 Hard Limit나 Soft Limit을 지정할 수 있다. Hard Limit를 지정하면 Container는 지정된 메모리량 이상을 사용할 수 없다. Sofr Limit를 지정하면 필요한만큼 메모리를 이용하다가 커널이 호스트 머신의 메모리가 부족하거나 컨첸션이 몰릴 경우 제한을 한다. memory와 -memory-swap을 이용해서, 물리메모리와 스왑메모리에 대한 제한을 걸 수 있다. –memory: 물리적인 메모리의 크기 –memory-swap: 스왑메모리 + 물리메모리의 크기 즉, 전체 메모리의 크기 옵션 설명 -m 혹은 –memory 컨테이너가 사용할 최대 메모리 양을 지정한다. 이 옵션을 지정할 때, 최소 값은 4m(4메가 바이트)이다. –memory-swap 컨테이너가 사용할 스왑 메모리 영역에 대한 설정을 할 수 있다. 자세한 내용은 밑에 적겠다. –memory-swappiness 기본적으로 호스트 운영체제의 커널은 컨테이너가 사용하고 있는 Anonymous Page의 일정 퍼센트를 스왑 아웃 할 수 있다. –memory-swappiness 는 0 ~ 100 사이의 값을 지정할 수 있으며, 호스트 운영체제에 의해 발생하는 anonymous page의 스왑 아웃을 지정할 수 있다. 0이 설정되면, anonymous page 스왑 기능을 끈다 100이 설정되면, 모든 anonymous page들이 스왑 아웃 될 수 있다. 설정하지 않으면 호스트 운영체제의 설정 값이 상속되어 사용되어진다. –memory-reservation –memory 설정으로 명시한 값보다 작은 값의 soft limit을 명시할 수 있게 해준다. 이 값은 Docker가 컨텐션을 감지하거나 호스트 머신에서 메모리 가용률이 낮아졌을 때 활성화된다. –memory-reservation 값은 –memory 설정 값보다 작아야한다. Soft limit이니만큼 컨테이너의 메모리 사용양은 이 제한을 넘을 수 있다. –kernel-memory 컨테이너가 사용할 수 있는 커널 메모리 양을 제한한다. 최소 값은 4m(4메가 바이트)이다. 커널 메모리는 스왑 아웃 되지 않기 때문에 커널 메모리를 지나치게 많이 사용하는 컨테이너는 호스트 머신의 커널 메모리를 점유하게 될 수 있다. 이는 호스트 머신이나 다른 컨테이너에게 사이드 이펙트를 만들어 낼 가능성이 있다. –oom-kill-disable OOM (Out-Of-Memory) 이 발생했을 때, 커널이 컨테이너에 존재하는 프로세스를 죽일 것인지 지정할 수 있는 옵션이다. 기본 설정은 프로세스를 죽인다. –oom-kill-disable 옵션이 켜져있으면, 컨테이너의 메모리 사용량이 늘어나다가 호스트 운영체제에 의해서 호스트 시스템의 프로세스가 Kill을 맞을 수 있다. 특정 상황에 쓰면 유용하다. Container 메모리 제한 --memory를 지정하면 Container의 메모리를 제한할 수 있다. 설정한 메모리 이상으로 사용하면 Container는 자동 종료된다.&gt; docker run -d ^ # -d 데몬 형태로 생성 &gt; --memory=\"1g\" ^ # --memory: 컨테이너의 메모리를 제한, 여기서는 1GB로 제한&gt; --memory-swap=\"3g\" ^ # --memory-swap: 스왑메모리를 설정할 수 있다, 여기서는 3GB로 설정했다.&gt; --name memory_1g ^ # --name: 컨테이너의 이름을 설정, 여기서는 \"memory_1g\"가 이름&gt; nginx # 이미지는 nginx를 사용 --memory-swap옵션을 –memory옵션이 설정되어 있을 때에 의미를 갖는다. 스왑 동작은 Container가 할당된 메모리를 모두 사용한 경우에도 디스크 공간을 끌어와서 쓸 수 있게 도와준다.CPU 자원 관리 Docker Container는 호스트 머신의 CPU자원을 제한 없이 사용할 수 있다. 즉, 하나의 Container가 수행될 때 CPU-Intensive한 작업을 실행하면, 호스트 머신의 CPU가 자원을 점유해 버릴 수 있다는 것이다. 이는 Container간 독립적인 환경을 구축할 수 없음을 의미하기 때문에 CPU사이클에 대한 쿼터를 적용할 필요가 있다는 것이다. 가상 머신의 경우 특정 갯수의 CPU를 할당 받지만 Container의 경우 전체 사용량에서 얼마나 사용할지를 결정한다. 옵션 설명 –cpus= Docker 컨테이너가 몇 개의 CPU를 사용할 것인지 명시한다. 예를 들어, 호스트 머신에 2개의 CPU가 있고, –cpus=”1.5”라고 옵션을 명시하면, 컨테이너가 최대한 1.5개의 CPU 파워를 사용할 수 있다는 의미이다. –cpus=”1.5”는 –cpu-period=”100000” 옵션과 –cpu-quota=”150000” 옵션을 동시에 준 것과 동일한 의미를 갖는다. Docker 버전 1.13 이상에서 지원된다. –cpu-period= CPU CFS 스케줄러 Period를 의미하며, –cpu-quota 옵션과 같이 사용한다. 기본 값은 1초이며, 마이크로초로 표현된다. 대부분의 유저는 이 값을 변경하지 않고 사용한다. Docker 1.13 버전 이후에는 –cpus 옵션을 사용하는 것을 권장한다. –cpu-quota= 컨테이너의 CPU CFS 쿼터(Quota)를 의미한다. –cpu-quota 로 입력한 값은 –cpu-period 로 입력한 값 중 얼마를 컨테이너에게 할당할 것인가를 의미한다. 즉, –cpu–quota/–cpu-period 가 사용할 리소스의 퍼센트이다. 마찬가지로 Docker 1.13 버전 이후에는 –cpus 옵션을 사용하는 것을 권장한다. –cpuset-cpus 컨테이너가 사용할 수 있는 CPU 혹은 코어를 제한한다. 코어를 지정하는 인덱스는 0부터 시작한다. 즉, 코어가 4개 있는 호스트 머신에서 컨테이너를 띄울 때, –cpuset-cpus=”0-3” 이라고 명시하면, 해당 컨테이너는 첫번 째, 두 번째, 세 번째, 네 번째 코어를 사용하게 된다. –cpuset-cpus=”0, 2” 이라고 명시하면, 첫 번째와 세 번째 코어를 사용하도록 명시한 것이다. –cpu-shares 컨테이너를 실행할 때 고려할 가중치라고 보면된다. 설정의 기본 값은 1024이며, 설정한 값은 상대적으로 사용된다. –cpu-shares=2048 로 설정하면, 기본 값보다 두 배 많은 CPU 자원을 할당한다. 이 설정 값은 리눅스 커널의 cgroups에서 사용된다. 이 값을 이용하여 CPU 자원을 50:50으로 할당할 수도 있고, 80:20으로 할당할 수도 있다. " }, { "title": "1. Docker File", "url": "/posts/Chap4-Docker_File/", "categories": "Docker, Chapter 4(DockerFile)", "tags": "Docker File", "date": "2022-04-10 22:00:00 +0900", "snippet": "1. Dockerfile 이란? Dockerfile은 Docker 상에서 작동시킬 Container의 구성정보를 기술하기 위한 파일이다. 필수는 아니지만 Dockerfile을 제작할 때에는 디렉토리를 생성한 뒤 해당 디렉토리에 접근해서 사용할 것을 권장한다. Dockerfile에는 다음의 기능들이 정의될 수 있다. Base가 될 Docker 이미지 Docker Container 안에서 수행한 조작 환경변수 등의 설정 Docker Container안에서 작동시켜 둘 데몬 실행 2. Dockerfile 기본 구성 Dockerfile은 텍스트 형식의 파일로 에디터 등을 사용하여 작성한다. 명령은 대문자, 소문자 상관없지만 관례적으로 대문자를 사용한다. Dockerfile에서 사용하는 주요명령을 소개한다. 명령어 설명 명령어 설명 FROM 베이스 이미지 지정 ADD 파일 추가 MAINTAINER 작성자 지정 COPY 파일 복사 RUN 명령어 실행 VOLUME 볼륨 마운트 CMD 데몬 실행 ENTRYPOINT 데몬 실행 LABEL 라벨 설정 USER 사용자 설정 EXPOSE 포트 내보내기 WORKDIR 작업 디렉토리 지정 ENV 환경 변수 설정 ONBUILD build 후 실행 명령 3. 베이스 이미지 지정(FROM) Dockerfile에는 Docker Container를 어떤 Docker 이미지로부터 생성할지 정보를 반드시 기술해야 한다. 이와 같은 이미지를 베이스 이미지라고 한다.FROM IMAGEFROM IMAGE:TAGFROM IMAGE@DIGEST FROM 명령은 필수적 이다. 만약 해당 이미지가 없으면 서버 저장소(Repository)에서 다운로드 받는다. ex&gt; CentOS를 베이스 이미지로 한 DockerfileFROM centos:centos7 태그명을 생략하면 베이스 이미지의 최신버전이 적용된다. 이미지명이나 태그명은 작성자가 임의의 값을 붙일수 있기 때문에 Dockerfile을 수정해도 똑같은 이름으로 몇 번이든 이미지를 만들수 있다. 이미지를 고유하게 특정할 때는 DIGEST를 이용한다. digest는 DockerHub에 업로드하면 자동으로 부여되는 식별자다. digest는 고유한 식별자이기 때문에 이미지를 고유하게 지정할 수 있다. digest 확인: docker image ls 명령에 –digest 옵션을 지정한다. Dockerfile에서 이미지를 고유하게 지정할 때는 이미지명 다음에 @마크를 붙이고 digest 값을 지정한다. 4. MAINTAINER MAINTAINER는 이미지를 생성한 사람의 정보를 설정한다. 형식은 자유이며 보통 다음과 같이 이름 &amp; E-MAIL을 입력한다. MAINTAINER 지시어는 필수 요소는 아니지만 이미지를 공개할 때 작성자가 누구인지 명시하는 역할을 한다.MAINTAINER Hong, Gildong &lt;gildong@licos.com&gt;5. Docker 이미지 생성(Build) docker build [OPTIONS] PATH | URL | - Dockerfile로 부터 이미지를 생성하려면 docker build 명령을 사용한다. Usage: docker image build [OPTIONS] PATH | URL | -Build an image from a DockerfileOptions: --add-host list Add a custom host-to-IP mapping (host:ip) --build-arg list Set build-time variables --cache-from strings Images to consider as cache sources --disable-content-trust Skip image verification (default true) -f, --file string Name of the Dockerfile (Default is 'PATH/Dockerfile') --iidfile string Write the image ID to the file --isolation string Container isolation technology --label list Set metadata for an image --network string Set the networking mode for the RUN instructions during build (default \"default\") --no-cache Do not use cache when building the image -o, --output stringArray Output destination (format: type=local,dest=path) --platform string Set platform if server is multi-platform capable --progress string Set type of progress output (auto, plain, tty). Use plain to show container output (default \"auto\") --pull Always attempt to pull a newer version of the image -q, --quiet Suppress the build output and print image ID on success --secret stringArray Secret file to expose to the build (only if BuildKit enabled): id=mysecret,src=/local/secret --ssh stringArray SSH agent socket or keys to expose to the build (only if BuildKit enabled) (format: default|&lt;id&gt;[=&lt;socket&gt;|&lt;key&gt;[,&lt;key&gt;]]) -t, --tag list Name and optionally a tag in the 'name:tag' format --target string Set the target build stage to build. ex&gt; Dockerfile 작성FROM centos:latest ex&gt; 현재 경로에 있는 Dockerfile로 부터 sample이라는 이름의 Docker 이미지를 생성한다.&gt; docker image build -t sample .Sending build context to Docker daemon 2.048kBStep 1/1 : FROM centos:latest---&gt; 9f38484d220fSuccessfully built 9f38484d220fSuccessfully tagged sample:latest ex&gt; 베이스 이미지인 centos:latest가 이미 로컬 환경에 다운로드된 상태에서 sample이라는 이름에 태그명 1.0이라는 버전으로 한 새로운 이미지를 작성한다.&gt; docker image build -t sample:1.0 .Sending build context to Docker daemon 2.048kBStep 1/1 : FROM centos:latest---&gt; 9f38484d220fSuccessfully built 9f38484d220fSuccessfully tagged sample:1.0&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 9f38484d220f 2 months ago 202MBsample 1.0 9f38484d220f 2 months ago 202MBsample latest 9f38484d220f 2 months ago 202MB Dockerfile에는 임의의 파일명을 붙일수 있다. 파일명은 docker build 명령에서 -f 옵션으로 지정한다. 단, 파일명이 Dockerfile 이외의 이름인 경우 Docker Hub에서 이미지의 자동 생성 기능을 사용할 수 없다. ex&gt; BaseDockerfile 이름의 dockerfile을 빌드한다. &gt; docker image build -t sample:2.0 -f BaseDockerfile .Sending build context to Docker daemon 2.048kBStep 1/1 : FROM centos:latest---&gt; 9f38484d220fSuccessfully built 9f38484d220fSuccessfully tagged sample:2.0&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 9f38484d220f 2 months ago 202MBsample 1.0 9f38484d220f 2 months ago 202MBsample 2.0 9f38484d220f 2 months ago 202MBsample latest 9f38484d220f 2 months ago 202MB --pull 옵션을 사용하면 매번 베이스 이미지를 강제로 새로 받아온다. 이미지를 빌드할 때 확실하게 최신 베이스 이미지를 사용하고 싶다면 다음과 같이 --pull-true 옵션을 붙여서 빌드한다.&gt; docker image build --pull-true -t sample:2.0 -f Basedockerfile .6. Docker 이미지의 레이어 구조 Dockerfile을 빌드하여 Docker 이미지를 작성하면 Dockerfile의 명령별로 이미지를 작성한다. 작성된 여러개의 이미지는 레이어 구조로 되어있다. 작성한 이미지는 다른 이미지와도 공유된다. 공통의 베이스 이미지를 바탕으로 여러 개의 이미지를 작성한 경우, 베이스 이미지의 레이어가 공유된다. 디스크 용량을 효율적으로 이용한다. ex&gt; Docker image의 레이거 구조 확인방법 Dockerfile FROM node:argon# Create app directoryRUN mkdir -p /usr/src/appWORKDIR /usr/src/app# Install app dependenciesCOPY package.json /usr/src/app/RUN npm install# Bundle app sourceCOPY . /usr/src/appEXPOSE 8080CMD [ \"npm\", \"start\" ] image build: 명령 한 줄마다 이미지가 작성된다.&gt; docker image build -t expressweb .Step 1 : FROM node:argonargon: Pulling from library/node......Status: Downloaded newer image for node:argon---&gt; 530c750a346eStep 2 : RUN mkdir -p /usr/src/app---&gt; Running in 5090fde23e44---&gt; 7184cc184ef8Removing intermediate container 5090fde23e44Step 3 : WORKDIR /usr/src/app---&gt; Running in 2987746b5fba---&gt; 86c81d89b023Removing intermediate container 2987746b5fbaStep 4 : COPY package.json /usr/src/app/---&gt; 334d93a151eeRemoving intermediate container a678c817e467Step 5 : RUN npm install---&gt; Running in 31ee9721cccb---&gt; ecf7275feff3Removing intermediate container 31ee9721cccbStep 6 : COPY . /usr/src/app---&gt; 995a21532fceRemoving intermediate container a3b7591bf46dStep 7 : EXPOSE 8080---&gt; Running in fddb8afb98d7---&gt; e9539311a23eRemoving intermediate container fddb8afb98d7Step 8 : CMD npm start---&gt; Running in a262fd016da6---&gt; fdd93d9c2c60Removing intermediate container a262fd016da6Successfully built fdd93d9c2c60" }, { "title": "1. Container 소개", "url": "/posts/Chap3-Container/", "categories": "Docker, Chapter 3(컨테이터)", "tags": "Docker Container", "date": "2022-04-10 22:00:00 +0900", "snippet": "1. Summary## 컨테이너 생성&gt; docker container create -it --name c1 centos## 컨테이너 시작&gt; docker container start c1## 컨테이너 정지&gt; docker container stop c1&gt; docker container pause c2## 컨테이너 생성 및 시작&gt; docker container run -it centos&gt; docker container run -it --name c2 centos## 컨테이너 재시작&gt; docker contaienr restart c1## 컨테이너 삭제&gt; docker container rm c1 c2&gt; docker container unpause c2## 컨테이너 확인&gt; docker ps&gt; docker container ls&gt; docker container inspect c8f2. Docker Container의 Life cycle Docker image가 만들어 졌으면 Container를 생성할 수 있다. docker container COMMAND&gt; docker container --helpUsage: docker container COMMANDManage containersCommands: attach Attach local standard input, output, and error streams to a running container commit Create a new image from a container's changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container's filesystem exec Run a command in a running container export Export a container's filesystem as a tar archive inspect Display detailed information on one or more containers kill Kill one or more running containers logs Fetch the logs of a container ls List containers pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container prune Remove all stopped containers rename Rename a container restart Restart one or more containers rm Remove one or more containers run Run a command in a new container start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers wait Block until one or more containers stop, then print their exit codes 컨테이너를 조작하기 위한 기본 명령은 5가지 이다. 조작 Command 설명 생성 docker container create 컨테이너를 시작할 준비가 된 상태 생성 및 시작 docker container run 이미지로부터 컨테이너를 생성 및 실행 시작 docker continer start 정지 중인 컨테이너를 시작 정지 docker container stop 실행 중인 컨테이너를 정지 삭제 docker container rm 컨테이너를 삭제 3. Container 생성 및 실행Container 생성docker contaienr create [OPTION] IMAGE [COMMAND] [ARG...] 이미지로부터 컨테이너를 생성한다.&gt; docker container create --helpUsage: docker create [OPTIONS] IMAGE [COMMAND] [ARG...]Create a new containerOptions: --add-host list Add a custom host-to-IP mapping...&lt;생략&gt;... -w, --workdir string Working directory inside the container 주요 옵션 Option 설명 -t or –interactive 표준 입력을 사용할 수 있도록 한다. -t or tty 표준 출력 및 표준 에러를 터미널로 출력한다. –name Container 이름을 지정한다. 도커 명령에서 자주 사용되는 옵션-i 옵션은 컨테이너를 실행할 때 컨테이너 쪽 표준 입력과의 연결을 그대로 유지한다. 그러므로 컨테이너 쪽 쉘에 들어가서 명령을 실행 할 수 있다. 실제 사용에서는 -t 옵션과 함께 사용하는 경우가 많다. -t 옵션은 유사 터미널 기능을 활성화하는 옵션인데, -i 옵션을 사용하지 않으면 유사 터미널을 실행해도 여기에 입력할 수가 없으므로 -i와 -t 옵션을 같이 사용한다. Container를 생성할 때, -i 옵션과 -t 옵션을 같이 사용하여 표준 입출력이 가능한 Container를 생성 한다. Container를 생성하면 STATUS가 Created 이다. ex&gt; centos 이미지를 c1이름으로 컨테이너화한다. &gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 75835a67d134 12 days ago 200MBpys6478/web centos 75835a67d134 12 days ago 200MB&gt; docker container create -it --name c1 centose9e056f426285681de9cfb08bde228db8f55ba268de08fcaae44830b4ee625a7&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES&gt; docker container ls -a(모든 상태의 컨테이너 조회)CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe9e056f42628 centos \"/bin/bash\" 5 seconds ago Created c1Container 시작docker container start [OPTIONS] CONTAINER [CONTAINER...] 정지되어 있는 Container를 시작할 때는 docker container start 명령을 사용한다.&gt; docker container start --helpUsage: docker container start [OPTIONS] CONTAINER [CONTAINER...]Start one or more stopped containersOptions: -a, --attach Attach STDOUT/STDERR and forward signals --detach-keys string Override the key sequence for detaching a container -i, --interactive Attach container's STDIN Container를 시작하면 STATUS가 Created에서 Up으로 변한다. ex&gt; 정지된 C1 Container를 시작한다. &gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe9e056f42628 centos \"/bin/bash\" 3 minutes ago Created c1&gt; docker container start c1c1&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe9e056f42628 centos \"/bin/bash\" 3 minutes ago Up 2 seconds c1 다수의 Container를 한꺼번에 시작하고 싶을 때는 인수에 Container 식별자를 여러개 지정한다.Shell 이미지와 Service 이미지의 차이점centos: shell imagehttpd: service imageshell 이미지는 -it 옵션을 하지 않으면 바로 종료된다.Container 정지docker container stop [OPTION] CONTAINER [CONTIANER...] 실행 중인 Container를 정지할 때는 docker container stop 명령을 사용한다.&gt; docker container stop --helpUsage: docker stop [OPTIONS] CONTAINER [CONTAINER...]Stop one or more running containersOptions: -t, --time int Seconds to wait for stop before killing it (default 10) STATUS가 Exited인 것을 확인할 수 있다. ex&gt; 실행 중인 C1 Container를 stop 한다. &gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe9e056f42628 centos \"/bin/bash\" 4 minutes ago Up 59 seconds c1&gt; docker container stop c1c1&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES&gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe9e056f42628 centos \"/bin/bash\" 4 minutes ago Exited (137) 4 seconds ago c1 정지 중인 모든 Container를 삭제하려면 docker container prune 명령을 사용한다.&gt; docker container pruneWARNING! This will remove all stopped containers.Are you sure you want to continue? [y/N] yDeleted Containers:38f3f39a879526fc9868f4ca9d2112a59270bd1b75ebb21f9a3693a1be1efb8c1a62d5eddbf4c8891986f9fc0f18ea70a0bdd8a00e2972bf7fce1b8723a28b8df6f9f7ae93976f381723df812893efa428fb691f0dfb442155d575ef94a81a2d345cd87a09fa9bf46e7c17d98b570dab51a863f9f6607e3be5c2d80f7a9bb7f5afda6b0720c2becec6374754e18a0c6c41bdde328abd24ebde080a6f02bc511dfc2d9ed61286d8920a1a8c24ff62ae71b6d4dce08ebfa65238e5492d9f51190a589b6812962f235b934521ecefcbba599741d021b3599d8a92c1ed067c668e12638ed23e4323c11d93cb1274bf14bbc879f34882007f847867617aeb77689e78ebe7fa1c6caca51264380f2e2a4e65be6c4af0fa9756f2edc278c5f54671de13Total reclaimed space: 1.754MBContainer 생성 및 실행docker container run [OPTIONS] IMAGE [COMMAND] [ARG...] docker Container의 생성 및 시작은 docker container run 명령으로 실행한다.&gt; docker container run --helpUsage: docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]Run a command in a new containerOptions: --add-host list Add a custom host-to-IP mapping (host:ip) -a, --attach list Attach to STDIN, STDOUT or STDERR...&lt;생략&gt;... -w, --workdir string Working directory inside the container ex&gt; 표준 입출력을 사용하도록 centos 이미지를 c2 이름으로 Container를 만들고 실행한다. -it 옵션 없이 실행하면 바로 종료된다. Ctrl + P + Q : Container 실행 중인 상태에서 빠져 나올 때 사용한다. Container를 종료시키려면 exit 명령을 사용한다. 이름을 생략하면 Container 이름은 랜덤으로 자동 설정된다. &gt; docker container run -it --name c2 centos# exitexit&gt; docker container run -it centos#&gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd5cb4b73816d centos \"/bin/bash\" 8 seconds ago Up 7 seconds ecstatic_montalcini5367c9819caa centos \"/bin/bash\" 2 minutes ago Exited (0) 2 minutes ago c2 Container 안에의 Shell을 실행할 수 있다. ex&gt; /bin/bash를 Container에서 실행한다. &gt; docker container run -it --name c4 centos /bin/bash#&gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1a3b95c47f92 centos \"/bin/bash\" 13 seconds ago Up 11 seconds c4 -d 옵션 : Container를 백그라운드로 실행한다. ex&gt; centos 이미지를 c3 이름으로 표준 입출력 백그라운드로 실행한다. &gt; docker container run -d -it --name c3 centos2ff8e89c352c83a58241a056dc6a7df86fde822e963ada8ef929ace4a333dae2&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2ff8e89c352c centos \"/bin/bash\" 3 seconds ago Up 2 seconds c3실행하자마자 종료되는 경우백그라운드에서 동작(예시: 서버 기능하는 이미지) =&gt; 표준입출력(-it)예제) 백그라운드에서 동작하는 http를 포그라운드에서 컨테이너를 실행시켜 보자.&gt; docker container run -d --name web1 httpdUnable to find image 'httpd:latest' locallylatest: Pulling from library/httpdf17d81b4b692: Pull complete06fe09255c64: Pull complete0baf8127507d: Pull complete1e5b6ba3cfcc: Pull completef09ae565a639: Pull completeDigest: sha256:378951edb85bfd57ddaf2edf482ec62e552667bfc4deeaf326342d481ac526f0Status: Downloaded newer image for httpd:latestca3d7fffa89ea18333a3d66e07e1a37b4700f556ba488ceeec2d1b04a49b0b84&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEhttpd latest 0240c8f5816c 2 days ago 132MB&gt; docker container run -it --name web2 httpdAH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.3. Set the 'ServerName' directive globally to suppress this messageAH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 172.17.0.3. Set the 'ServerName' directive globally to suppress this message[Mon Oct 22 06:49:17.255292 2018] [mpm_event:notice] [pid 1:tid 140109860508864] AH00489: Apache/2.4.35 (Unix) configured -- resuming normal operations[Mon Oct 22 06:49:17.255468 2018] [core:notice] [pid 1:tid 140109860508864] AH00094: Command line: 'httpd -D FOREGROUND'C[Mon Oct 22 06:50:03.334138 2018] [mpm_event:notice] [pid 1:tid 140109860508864] AH00491: caught SIGTERM, shutting down&gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES97d54155d306 httpd \"httpd-foreground\" About a minute ago Exited (0) 27 seconds ago web2 표준 입출력 옵션(-it)을 추가 안한 경우 컨테이너를 실행하고 바로 종료된다. ex&gt; shell 이미지인 centos를 -it 옵션을 추가하지 않고 실행시켜 본다.&gt; docker container run --name c1 centos&gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES56154a39a0bc centos \"/bin/bash\" 6 seconds ago Exited (0) 5 seconds ago c1Container 재시작docker container restart [OPTIONS] CONTAINER [CONTAINER...] Container를 재시작할 때는 docker container restart 명령을 사용한다.&gt; docker container restart --helpUsage: docker container restart [OPTIONS] CONTAINER [CONTAINER...]Restart one or more containersOptions: -t, --time int Seconds to wait for stop before killing the container (default 10) -t –time 옵션을 사용하면 n초 후 Container를 재시작할 수 있다. ex&gt; 2초 후 c1 Container를 재시작한다. &gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2a3a5409c47e centos \"/bin/bash\" About a minute ago Exited (137) 56 seconds ago c1&gt; docker container restart -t 2 2a32a3&gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2a3a5409c47e centos \"/bin/bash\" About a minute ago Up 4 seconds c1 Container 안에서 실행하는 명령의 종료 STATUS에 따라 컨테이너를 자동으로 재시작하고 싶은 경우는 docker container run 명령에서 --restart 옵션을 사용한다.(default는 restart no 이다.) ex&gt; Container가 종료될 경우 Docker가 다시 시작하도록 redis Container를 실행한다. &gt; docker container run --restart=always redis Policy Result no 컨테이너가 종료되면 자동으로 재시작하지 않는다.(default) on-failure 컨테이너가 0이 아닌 종료상태로 종료될 때만 다시 시작한다. 선택적으로 docker 데몬이 시도하는 재시작 횟수를 제한할 수 있다. always 종료 상태에 관계 없이 항상 컨테이너를 다시 시작한다. unless-stopped 컨테이너가 중지 상태가 된 경우를 제외하고는 재시작한다. Container 삭제docker container rm [OPTIONS] CONTAINER [CONTAINER...] 중지(Exited)된 Container를 삭제할 때는 docker container rm명령을 사용한다.&gt; docker container rm --help&gt; Usage: docker container rm [OPTIONS] CONTAINER [CONTAINER...]Remove one or more containersOptions: -f, --force Force the removal of a running container (uses SIGKILL) -l, --link Remove the specified link -v, --volumes Remove the volumes associated with the container 여러 개의 Container를 한꺼번에 삭제할 때는 인수에 Container 식별자를 여러개 지정한다. ex&gt; c1, c2, c3 이름의 컨테이너 삭제 &gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4469905e024a centos \"/bin/bash\" 5 seconds ago Exited (0) 3 seconds ago c3856aefb5aba6 centos \"/bin/bash\" 12 seconds ago Exited (0) 8 seconds ago c2edf6a916287b centos \"/bin/bash\" 19 seconds ago Exited (0) 14 seconds ago c197d54155d306 httpd \"httpd-foreground\" 3 minutes ago Exited (0) 3 minutes ago web2ca3d7fffa89e httpd \"httpd-foreground\" 12 minutes ago Up 12 minutes 80/tcp web1&gt; docker container rm c1 c2 c3c1c2c3&gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES97d54155d306 httpd \"httpd-foreground\" 3 minutes ago Exited (0) 3 minutes ago web2ca3d7fffa89e httpd \"httpd-foreground\" 12 minutes ago Up 12 minutes 80/tcp web1 Container를 삭제하려면 먼저 중지(Exited) 상태여야한다. ex&gt; 실행 중인 Container c1을 삭제한다. &gt; docker container rm c1Error response from daemon: You cannot remove a running container 2a3a5409c47ef31c226b5c34ca011a801ca5ca2b8163975b743ba78670ca9c67. Stop the container before attempting removal or force remove -f 옵션: 실행 중인 상태의 Container를 갈제적으로 삭제한다. ex&gt; web1 이름의 실행 중인 컨테이너를 삭제한다. &gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESca3d7fffa89e httpd \"httpd-foreground\" 13 minutes ago Up 13 minutes 80/tcp web1&gt; docker container rm -f web1web1&gt; docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES97d54155d306 httpd \"httpd-foreground\" 4 minutes ago Exited (0) 3 minutes ago web2 새로 이름 붙인 Container를 생성할 때 같은 이름을 가진 기존 Container가 존재하는 경우 새로운 Container를 생성할 수 없다.(같은 이름의 Container를 삭제해야한다.)불필요한 이미지/컨테이너를 일괄 삭제docker system prune [OPTIONS] docker system prune 명령을 사용하면 사용하지 않는 이미지, 컨테이너, 볼륨, 네트워크를 일괄적으로 삭제할 수 있다.&gt; docker system prune --helpUsage: docker system prune [OPTIONS]Remove unused dataOptions: -a, --all Remove all unused images not just dangling ones --filter filter Provide filter values (e.g. 'label==') -f, --force Do not prompt for confirmation --volumes Prune volumes ex&gt; 사용하지 않는 리소스를 모두 삭제한다. 디스크 낭비를 줄일 수 있다.&gt; docker system prune -aWARNING! This will remove: - all stopped containers - all networks not used by at least one container - all images without at least one container associated to them - all build cacheAre you sure you want to continue? [y/N] yDeleted Containers:d3ed594d193b0d3402a447a85a3278ff335b329c4b92801e6c24ada0404ed2adDeleted Networks:temp_default...&lt;생략&gt;...Total reclaimed space: 4.332GB 실행 중이 아닌 모든 컨테이너를 삭제하는 명령은 docker container prune이다. 정지시킨 대부분의 컨테이너는 그리 쓸모가 없기 때문에 정기적으로 이들을 삭제하는 것이 좋다.&gt; docker container prune docker image prune 명령은 태그가 붙지 않은(dangling) 모든 이미지를 삭제한다.&gt; docker image pruneContainer 중단docker container pause CONTAINER [CONTAINER...] 실행중인 컨테이너에서 작동 중인 프로세스를 모두 중단시킬 때는 docker container pause명령을 사용한다.&gt; docker container pause --helpUsage: docker pause CONTAINER [CONTAINER...]Pause all processes within one or more containers STATUS 필드에 (Paused)가 표시되어 있으면 컨테이너가 일시 중지된 상태이다. ex&gt; web1 컨테이너 일시 중지한다. &gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1e220a23ba2e httpd \"httpd-foreground\" 12 minutes ago Up 12 minutes 80/tcp web1&gt; docker container pause web1web1&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES1e220a23ba2e httpd \"httpd-foreground\" 12 minutes ago Up 12 minutes (Paused) 80/tcp web1Note[STOP VS PAUSE]STOP: 컨테이너가 사용 중인 자원 모두 해제한다.PAUSE: 컨테이너가 사용 중인 자원 해제하지 않는다.Container 재개docker container unpause CONTAINER [CONTAINER...] 중지중인 컨테이너를 재개할 때는 docker container unpause명령을 사용한다.&gt; docker container unpause --helpUsage: docker unpause CONTAINER [CONTAINER...]Unpause all processes within one or more containers4. Container 확인docker container ls [OPTION] ps 명령어와 같이 가동 중인 Container 리시트를 보여준다.&gt; docker container ls --helpUsage: docker container ls [OPTIONS]List containersAliases: ls, ps, listOptions: -a, --all Show all containers (default shows just running) -f, --filter filter Filter output based on conditions provided --format string Pretty-print containers using a Go template -n, --last int Show n last created containers (includes all states) (default -1) -l, --latest Show the latest created container (includes all states) --no-trunc Don't truncate output -q, --quiet Only display numeric IDs -s, --size Display total file sizes -q 옵션을 사용하면 Container ID만을 추출할 수 있다. 표시할 Container를 필터링할 때는 -f 옵션을 지정한다.(Filtering 조건은 key=value로 지정한다.) ex&gt; 이름이 c1인 Container를 조회한다. &gt; docker container ls -a -f name=c1CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES2a3a5409c47e centos \"/bin/bash\" About an hour ago Up About an hour c1 출력 형식을 변경하고 싶을 때는 --format 옵션을 지정한다. ex&gt; Container ID와 가동 중인지 아닌지의 상태를 콜론으로 구분하여 표시한다. &gt; docker container ls -a --format \": \"c1: Up About an hour Container 가동 확인docker container stats [OPTIONS] [CONTAINER...] Container 가동 상태가 실시간 목록으로 표시된다.&gt; docker container stats --helpUsage: docker container stats [OPTIONS] [CONTAINER...]Display a live stream of container(s) resource usage statisticsOptions: -a, --all Show all containers (default shows just running) --format string Pretty-print images using a Go template --no-stream Disable streaming stats and only pull the first result --no-trunc Do not truncate output ex&gt; c1 Container의 가동 상황을 확인한다.&gt; docker container stats c1CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS2a3a5409c47e c1 0.00% 948KiB / 1.934GiB 0.05% 1.39kB / 0B 0B / 0B 1CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS2a3a5409c47e c1 0.00% 948KiB / 1.934GiB 0.05% 1.39kB / 0B 0B / 0B 1CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS2a3a5409c47e c1 0.00% 948KiB / 1.934GiB 0.05% 1.39kB / 0B 0B / 0B 1CONTAINER ID NAME CPU % MEM USAGE / LIMIT MEM % NET I/O BLOCK I/O PIDS2a3a5409c47e c1 0.00% 948KiB / 1.934GiB 0.05% 1.39kB / 0B 0B / 0B 1 Container 세부사항 확인docker sontainer inspect Container 뿐만 아니라 docker에서 사용되는 Network, Volume 등 모든 리소스를 자세히 확인한다.&gt; docker container inspect --helpUsage: docker inspect [OPTIONS] NAME|ID [NAME|ID...]Return low-level information on Docker objectsOptions: -f, --format string Format the output using the given Go template -s, --size Display total file sizes if the type is container --type string Return JSON for specified type ex&gt; 이름이 c1인 Container를 자세히 확인한다.&gt; docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESc8fe27fdfc39 centos \"bash\" 6 minutes ago Up 16 seconds stoic_kalam&gt; docker container inspect c8f[ { \"Id\": \"c8fe27fdfc390389b7612f7465c9299d93cf888c855757e39bb62b5fe918da69\", \"Created\": \"2018-10-22T06:11:58.00252796Z\",... &lt;생략&gt; \"DriverOpts\": null } } } }]" }, { "title": "1. Image 관리", "url": "/posts/Chap2-ImageManage/", "categories": "Docker, Chapter 2(이미지 관리))", "tags": "Image Manage", "date": "2022-04-07 22:00:00 +0900", "snippet": "Docker Image## 이미지 검색&gt; docker search hello-world## 즐겨찾기 수 1000이상의 이미지 검색&gt; docker search centos -s 1000&gt; docker search -f stars=1000 centos## 이미지 다운로드&gt; docker image pull centos:7## 이미지 목록 표시&gt; docker image ls&gt; docker images## 이미지 상세 정보 확인&gt; docker image inspect centos:7## 이미지 태그 설정&gt; docker image tag nginx mirero/webserver:1.0## 이미지 삭제&gt; docker rmi hello-world&gt; docker image rm hello-world&gt; docker image rm -f 9f&gt; docker image prune## 이미지 업로드&gt; docker login&gt; docker tag centos:latest jh0105123/centos:v2&gt; docker image push jh0105123/centos:v2&gt; docker logoutDocker Hub https://hub.docker.com/ Docker Hub는 GitHub나 Bitbucket과 같은 소스코드 관리 툴과 연계하여 코드를 빌드하는 기능이나 실행 가능한 애플리케이션의 이미지를 관리하는 기능을 갖춘 docker의 공식 레포지토리 서비스이다. Docker Hub를 사용하여 물리 서버든, 가상 머신이든, 클라우드든 Docker이미지를 배포할 수 있다. Docker Hub 사이트의 검색 키워드에 임의의 문자를 입력하여 검색하면 등록되어 있는 Docker의 이미지의 목록이 표시된다.이미지 검색docker search [Options] 이미지 키워드 Docker Hub에 공개된 이미지를 검색할 때는 docker search 명령을 사용한다. Docker Certified로고는 Image에 대한 품질, 출처 및 지원에 대한 보증을 제공한다. &gt; docker search --helpUsage: docker search [OPTIONS] TERMSearch the Docker Hub for imagesOptions:-f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output ex&gt; Hello-world 키워드를 포함한 이미지를 검색한다.&gt; docker search hello-worldNAME DESCRIPTION STARS OFFICIAL AUTOMATEDhello-world Hello World! (an example of minimal Dockeriz… 694 [OK]kitematic/hello-world-nginx A light-weight nginx container that demonstr… 111tutum/hello-world Image to test docker deployments. Has Apache… 56 [OK]... &lt;생략&gt;uniplaces/hello-world 0lkungs/docker-hello-world Simple Hello World Example 0 [OK] STARS 필드는 즐켜찾기 수이다. -s 옵션을 사용하면 일정 개수 이상의 STAR를 부여받은 이미지를 검색할 수 있다. ex&gt; 1000개 이상의 STAR를 부여받은 centos 키워드의 이미지를 검색 &gt; docker search centos -s 1000Flag --stars has been deprecated, use --filter=stars=3 insteadNAME DESCRIPTION STARS OFFICIAL AUTOMATEDcentos The official build of CentOS. 4834 [OK]&gt; docker search -f stars=1000 centosFlag --stars has been deprecated, use --filter=stars=3 insteadNAME DESCRIPTION STARS OFFICIAL AUTOMATEDcentos The official build of CentOS. 6541 [OK] 항목 설명 NAME 이미지 이름 DESCRIPTION 이미지 설명 STARS 즐겨찾기 수 OFFICIAL 공식 이미지 사실 여부(공식이면 [OK]) AUTOMATED Dockerfile을 바탕으로 자동 생성된 이미지 여부 --limit 옵션으로 최대 검색 건수를 제한할 수도 있다. 검색 결과는 STARS순으로 출력된다. ex&gt; mysql 이미지 중 상위 5개를 출력한다. 첫번째 출력되는 mysql 리포지토리 이름에는 namespace가 생략되어 있는데 이는 공식 리포지토리이기 때문이다. 공식 리포지토리의 네임스페이스는 일률적으로 library이며 생략할 수 있다. &gt; docker search --limit=5 mysqlNAME DESCRIPTION STARS OFFICIAL AUTOMATEDmysql MySQL is a widely used, open-source relation… 8250 [OK]mysql/mysql-server Optimized MySQL Server Docker images. Create… 616 [OK]mysql/mysql-cluster Experimental MySQL Cluster Docker images. Cr… 45bitnami/mysql Bitnami MySQL Docker Image 27 [OK]circleci/mysql MySQL is a widely used, open-source relation… 11이미지 다운로드(image pull)docker image pull [OPTIONS] NAME[:TAG|@DIGEST] Docker Hub에서 이미지 다운로드는 docker image pull 명령을 사용한다.&gt; docker image pull --help Usage: docker pull [OPTIONS] NAME[:TAG|@DIGEST]Pull an image or a repository from a registryOptions: -a, --all-tags Download all tagged images in the repository --disable-content-trust Skip image verification (default true) Tag는 각 이미지의 기능이나 버전이다. ex&gt; CentOS의 버전 7을 다운로드한다. &gt; docker image pull centos:77: Pulling from library/centosDigest: sha256:b5e66c4651870a1ad435cd75922fe2cb943c9e973a9673822d1414824a1d0475Status: Downloaded newer image for centos:7 태그를 지정하지 않으면 자동으로 lastest 태그가 지정된다. ex&gt; Docker에서 공식으로 제공하는 centos:lastest 이미지를 다운로드한다. &gt; docker image pull centosUsing default tag: latestlatest: Pulling from library/centosaeb7866da422: Pull completeDigest: sha256:67dad89757a55bfdfabec8abd0e22f8c7c12a1856514726470228063ed86593bStatus: Downloaded newer image for centos:latest -a 옵션을 지정하면 모든 태그를 취든할 수 있다. ex&gt; centos의 모든 태그 이미지를 취득한다. &gt; docker image pull -a centos DIGEST: 각 이미지가 가지고 있는 해시 값이다.이미지 목록표시(image ls)docker image lsdocker images Docker Hub에서 다운로드하여 로컬에 저장되어 있는 이미지의 목록을 확인하려면 위의 명령을 사용한다. docker images는 이전 명령어이다.&gt; docker image ls --helpUsage: docker image ls [OPTIONS] [REPOSITORY[:TAG]]List imagesAliases: ls, images, listOptions: -a, --all Show all images (default hides intermediate images) --digests Show digests -f, --filter filter Filter output based on conditions provided --format string Pretty-print images using a Go template --no-trunc Don't truncate output -q, --quiet Only show numeric IDs ex&gt; Docker 이미지 목록을 표시한다.&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 75835a67d134 12 days ago 200MB Docker 이미지를 작성하면 고유한 이미지 ID가 부여된다. 이미지 ID는 랜덤하다. 항목 설명 REPOSITORY 이미지 이름 TAG 이미지 태그명 IMAGE ID 이미지 ID CREATED 작성 일 SIZE 이미지 크기 이미지 상세 정보 확인(image inspect)docker image inspect [OPTIONS] IMAGE [IMAGE...] 이미지 상세 정보를 확인하려면 docker image inspect 명령을 사용한다.&gt; docker image inspect --helpUsage: docker image inspect [OPTIONS] IMAGE [IMAGE...]Display detailed information on one or more imagesOptions: -f, --format string Format the output using the given Go template ex&gt; centos:7 이라는 이미지 상세정보를 확인한다.&gt; docker image inspect centos:7[ { \"Id\": \"sha256:9f38484d220fa527b1fb19747638497179500a1bed8bf0498eb788229229e6e1\",...&lt;생략&gt;... \"Created\": \"2019-03-14T21:19:53.361167852Z\",...&lt;생략&gt;... \"DockerVersion\": \"18.06.1-ce\",...&lt;생략&gt;... \"Architecture\": \"amd64\",] 결과는 JSON형식으로 표시된다. –format 옵션을 사용하여 원하는 데이터 값만 출력할 수 있다. ex&gt; centos:7의 os 정보만 출력한다. &gt; docker image inspect --format=\"\" centos:7linux 이미지 태그 설정(image tag)docker image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] Docker 이미지에 붙는 태그는 이미지의 특정 버전을 구별 하기 위한 것이다. 애플리케이션을 수정하고 이미지를 빌드하면 매번 다른 이미지가 된다. 원래 같은 이미지였지만, 수정 후에는 다른 IMAGE ID값이 할당된다.&gt; docker image tag --helpUsage: docker image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE이미지 삭제(image rm)docker image rm [OPTIONS] IMAGE [IMAGE...] 작성한 이미지를 삭제하려면 docker image rm 명령을 사용한다.&gt; docker image rm --helpUsage: docker image rm [OPTIONS] IMAGE [IMAGE...]Remove one or more imagesOptions: -f, --force Force removal of the image --no-prune Do not delete untagged parents ex&gt; hello-world 이미지를 삭제한다.&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest 4ab4c602aa5e 6 weeks ago 1.84kB&gt; docker image rm hello-worldUntagged: hello-world:latestUntagged: hello-world@sha256:0add3ace90ecb4adbf7777e9aacf18357296e799f81cabc9fde470971e499788Deleted: sha256:4ab4c602aa5eed5528a6620ff18a1dc4faef0e1ab3a5eddeddb410714478c67fDeleted: sha256:428c97da766c4c13b19088a471de6b622b038f3ae8efa10ec5a37d6d31a2df0b&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZE 여러 개의 이미지를 삭제하고 싶을 때는 여러 이미지명을 스페이스로 구분하여 지정한다. -f 옵션으로 Image ID가 같은 여러개의 이미지를 동시에 삭제할 수 있다. ex&gt; Image ID가 9f3으로 시작하는 2개의 이미지를 삭제한다. &gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos v2 9f38484d220f 2 months ago 202MBcentos latest 9f38484d220f 2 months ago 202MB&gt; docker image rm -f 9fUntagged: jh0105123/centos:v2Untagged: centos:latestUntagged: centos@sha256:b5e66c4651870a1ad435cd75922fe2cb943c9e973a9673822d1414824a1d0475Deleted: sha256:9f38484d220fa527b1fb19747638497179500a1bed8bf0498eb788229229e6e1Deleted: sha256:d69483a6face4499acb974449d1303591fcbb5cdce5420f36f8a6607bda11854&gt; docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEdocker image prune [OPTIONS] 사용하지 않은 Docker 이미지를 삭제할 때는 docker image prune 명령을 사용한다.&gt; docker image prune --helpUsage: docker image prune [OPTIONS]Remove unused imagesOptions: -a, --all Remove all unused images, not just dangling ones --filter filter Provide filter values (e.g. 'until=') -f, --force Do not prompt for confirmation 사용하지 않은 Docker 이미지는 디스크 용량을 차지하기 때문에 정기적으로 삭제하는 것이 좋다.이미지 업로드(image push) Docker Hub에 가입한다. Docker Hub Docker Hub 로그인한다.: docker login&gt; docker loginLogin with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.Username: banjungPassword:Login Succeeded 사용자가 제작한 이미지를 Docker Hub에 업로드 하려면 docker tag를 사용하여 사용자 ID/Repository:tag 형식으로 이미지 이름을 변경해야한다.&gt; docker image tag centos:latest banjung/centos:v2docker push [OPTIONS] NAME[:TAG] Docker Hub에 이미지를 업로드하려면 docker image push 명령을 사용한다.&gt; docker image push --helpUsage: docker push [OPTIONS] NAME[:TAG]Push an image or a repository to a registryOptions: --disable-content-trust Skip image signing (default true) docker logout명령 으로 로그아웃하여 종료한다." }, { "title": "1. Docker 소개", "url": "/posts/Chap1-Intro/", "categories": "Docker, Chapter 1(Docker 소개))", "tags": "Docker Intro", "date": "2022-04-05 11:00:00 +0900", "snippet": "SummaryDocker 컨테이너 기반의 오픈 소스 가상화 플랫폼이다.이미지 컨테이너 실행에 필요한 파일과 설정값 등을 포함한다. 상태값을 가지지 않고 변하지 않는다.(Immutable)컨테이너 OS를 가상화해 여러 개의 고립된 리눅스 시스템을 실행하는 방법이다.기능 Build: Docker 이미지를 만드는 기능 Ship : Docker 이미지를 공유하는 기능 Run : Docker 컨테이너를 작동시키는 기능Docker란? 컨테이너를 사용해서 응용 프로그램을 개발, 배포 및 실행하기 위한 오픈소스 가상화 플랫폼이다.Docker Platform, Engine 컨테이너 기술을 사용하여 애플리케이션의 실행 환경을 구축 및 운용하기 윈한 플랫폼 애플리케이션의 실행에 필요한 환경을 하나의 이미지로 모아 관리함으로 이식성을 높힌다. 격리와 보안이 된 OS에 많은 컨테이너를 적재하여 동시에 실행할 수 있다. VM의 경우 각기 다른 OS를 동시에 구동할 수 있는 반면 컨테이너 환경은 컨테이너 가상화 보다 훨씬 가벼운 기술이다. Docker Engine은 데몬 프로세스라고 부르는 장기 실행 프로그램의 일정인 서버와 데몬이 통신할 수 있도록 인터페이스를 제공하는 REST API, CLI로 구성된다. CLI는 Dockered 커맨드로 수행되는 데몬 프로세스는 이미지, 컨테이너, 네트워크, 볼륨 등의 Docker 객체들을 생성하고 관리한다.Docker 사용의 이점 빠르고 일관된 애플리케이션 제공 애플리케이션과 서비스를 제공하는 로컬 컨테이너를 사용하여 표준화 된 환경에서 작업 할 수 있도록 한다.(개발 수명주기 간소화) 컨테이너는 지속적 통합 및 지속적 배포(CI / CD) workflow에 적합하다. 반응형 배포 및 확장 개발자의 로컬 PC, 가상 머신, 클라우드 등 혼합 환경에서 실핼할 수 있다. 동일한 하드웨어에서 더 많은 Workload 실행 가볍고 빠르다. Hypervisor 기반 가상 머신에 대한 실행이 가능하고 비용이 효율적이다. 적은 리소스로 많은 작업을 수행해야 하는 고밀도 환경과 중소 규모 배포에 적합하다. Docker의 배경Monolithic 에서 Microservie로 Architecture 변경 Monolithic Architecture 기존의 전통적인 웹 시스템 개발 스타일로 하나의 애플리케이션 내에 모든 로직이 들어가 있는 통짜 구조 이다. Microservice Architecture 소프트웨어가 잘 정의된 API를 통해 통신하는 소규모의 독립적인 서비스로 구성되어 있는 경우의 소프트웨어 개발을 위한 아키텍처 및 조직적 접근 방식이다. 대형 Apllication들은 다양한 기기와 환경들에 맞춰 빠르게 지원하기 위해 잘게 쪼개졌으며, 개발자들은 최상의 성능을 위해서 사용 가능한 Service들을 개별적으로 조립하여 제공 하였다.가상머신의 등장 컴퓨터 안에서 컴퓨터를 만들어내기 위한 시도이다. 컴퓨터 성능이 급격히 좋아지면서 PC에서도 흔히 사용한다. 서버 성능이 너무 좋아져 대부분 시간을 서버가 놀고있는 문제가 발생한다. 서버에 가상머신을 여러개 띄워서 동일시간 작업량을 늘린다. 가상화 흔히 알고있는 가상화(Virtualization)는 VMWare Workstation과 같은 소프트웨어를 이용해, Linux나 MacOS위에 Windows를 올려서 사용하는 그런 것을 떠올릴 수 있다. 이런 방식들이 하드웨어와 소프트웨어를 결합하여 가상 머신(VM)을 만들어 사용하는, Platform 가상화를 의미한다. Platform 가상화는 주어진 하드웨어 Platform 위에서 제어 프로그램, 즉 Host 소프트웨어를 통해 실행된다. Host 소프트웨어는 Host 환경 내의 Guest 소프트웨어에 맞춰 가상 머신(VM)을 만들어낸다. Guest 소프트웨어는 완전한 운영체제이며, 독립된 하드웨어 Platform에 설치된 것처럼 실행된다. 가상화 작동원리 물리저 서버 하드웨어에 운영 체제를 직접 설치하는 대신 하이퍼바이저 소프트웨어를 설치하여 하나의 물리적 시스템을 가상 머신이라는 분리된 여러 가상 환경으로 분할하는 방식으로 구현된다. 가상화의 장점 성질 내용 유연성 동일한 하드웨어에서 여러 운영 체제를 동시에 실행할 수 있다. 민첩성 한 물리적 서버에서 다른 물리적 서버로 파일이나 사진을 이동하는 것처럼 운영 체제 이동이 가능하다. 내결함성 물리적 서버에 장애가 발생하면 관리 소프트웨어는 이용 가능한 다른 서버로 신속하게 Instance를 Migration 하여 물리적 하드웨어에 장애가 발생했다는 것조차 알 수 없도록 조치합니다. 비용 효율성 필요한 물리적 서버 수를 줄일 수 있고 전기 요금과 운영 및 유지보수 비용도 절감할 수 있습니다. Hypervisor 가상화 vs Container 가상화 Virtual Machine(KVM. Xen) Container(LXC, Docker) 하이퍼바이저를 통한 컴퓨팅 가상화로 Guest OS를 동작시킨다. OS를 가상화해 여러 개의 고립된 리눅스 시스템을 동작시킨다. Container 가상화는 호스트 OS에서 논리적으로 구역을 만들어 어플리케이션과 어플리케이션에 필요한 라이브러리를 집어넣고, 독립적인 어플리케이션이 동작하는 서버처럼 만드는 가상화 기법이다. Container 가상화는 가상 머신의 OS가 필요하지 않기 때문에 필요한 리소스가 호스트 가상화나 하이퍼바이저 가상화보다 매우적다. Container 가상화는 가볍로 빠르며 가상의 OS가 없기 때문에 Overhead가 적다는 특징이 있다. Hyperviser 기반의 가상시스템에서 어플리케이션을 구동하려면 실제 구동되기 까지의 시간이 길게 걸리지만, Container는 이미 시스템이 동작되고 있는 상태에서 어플리케이션 부분만 가상화 되어 실행되기 때문에 속도가 훨씬 빠르다.전가상화(VM) vs 반가상화(Container) 이미지 추가리눅스 컨테이터(LXC) 전가상화든 반가상화든 추가적인 OS를 설치하여 가상화하는 방법은 성믄문제가 있었고 이를 개선하기위해 프로세스를 격리하는 방식이 등장한다. 리눅스에서는 이 방식을 리눅스 컨테이너라고 하고 단순히 프로세스를 격리시키기 때문에 가볍고 빠르게 동작한다. CPU나 메모리는 딱 프로세스가 필요한 만큼만 추가로 사용하고 성능적으로도 거의 손실이 없다. 리눅스 커널의 namespaces, cgroupsnamespacesDocker는 컨테이너라는 독립된 환경을 만들고 이 환경에서 어플리케이션을 실행한다. namespace는 독립된 환경을 만들 때 사용하는 기능 중 하나이다.namespace를 번역하면 '이름공간'이다. Docker가 독립된 환경을 만들 때 namespace 기능을 사용하여 각 환경에 이름을 부여하고 쉽게 참조 될 수 있도록한다.namespace를 사용하여 다음의 독립된 환경을 구축할 수 있다.cgroupDocker는 호스트의 리소스를 공유하여 사용한다. 이 때 사용되는 기능이 cgroup이다.cgroup은 프로세스 또는 쓰레드(thread)를 그룹화하여 관리하는 기능이다. 이를 통해 호스트의 CPU나 메모리를 그룹별로 제한할 수 있다.또한 같은 호스트에서 동작하는 서로 다른 컨테이너에 영향을 주지 않도록 막아주는 역할도 한다. 가상화가 아닌 격리 개념이다.Container의 한계 기존 Hypervisor 기반의 가상화 기술보다 Container가 뛰어난 부분은 앞서 얘기한 것처럼 속도가 빠르고 자원 소비율이 적기 때문에, 같은 자원을 갖고 있는 Host 시스템에서 더 많은 Application을 가상화 기반 위에 동작시킬 수 있다는 점이다. 하지만 Docker의 기반이 되는 Container기술은 Application의 구동 환경을 가상화하기 때문에, 호스트 시스템에서 제공하는 운영체제와 같은 환경에서만 제공한다는 단점이 있다. 즉, 일반 Docker 환경(Linux)에서 Windows Application 실행은 현재로선 어렵다는 것이다. 이는 Container 기술 자체가 운영체제와 실행 바이너리, 라이브러리를 공유하면서 Application 자체의 실행 환경만 가상화하여 제공하는 기술이기 때문에 어쩔 수 없는 상황이다.Docker의 특징 게스트 OS를 설치하지 않는다. 이미지에 서버 운영을 위한 프로그램과 라이브러리만 격리해서 설치한다. 이미지 용량이 크게 줄어들었다. 하드웨어 가상화 계층이 없다. 메모리 접근, 파일 시스템, 네트워크 전송 속도가 가상머신에 비해 월등히 빠르다. 환경에 구애받지 않고 Application을 신속하게 배포 및 확장할 수 있는 환경을 제공해준다. 이미지 버전관리도 제공하고 중앙 저장소에 이미지를 올리고 받을 수 있다. GitHub와 비슷한 형태의 Docker Hub(repository)에서 도커 이미지가 공유 가능하다. 다양한 API를 제공하여 원하는 만큼 자동화가 가능하다. Docker를 사용하는 이유? Docker는 Application 및 Service를 Container를 사용하여 표준화된 환경에서 구동할 수 있도록 한다. 개발 주기를 단축시켜 빠르게 배포할 수 있다. Container의 이점은 CI/CD Workflow에서 극대화된다. 환경에 따라, 배포와 확장이 자유롭다. Docker는 개발자의 Laptop, Datacenter의 VM, Cloud 환경 또는, 여러 다양한 환경에 쉽게 이식하여 사용할 수 있다. Docker의 이런 특성으로 인해, 비즈니스 요구 사항에 맞춰 Application과 Service를 부하에 따라 동적으로 관리할 수 있으며, 거의 실시간으로 축소 또는 확장할 수 있다.Docker의 구성요소Docker Daemon Docker Daemon(dockerd)은 Client로부터 API 요청을 수신하고 Image, Container, Network 및 Volume과 같은 Docker Object를 관리한다. Daemon은 Docker 서비스를 관리하기 위해 다른 Daemon과 통신할 수 있다. Docker Client Docker Client(docker)는 사용자가 Docker Daemon과 통신하는 주요 방법이다. docker run과 같은 명령을 사용하면 Docker Client는 해당 명령을 Docker Daemon으로 전송하여 명령을 수행하게 한다. docker 명령은 Docker API를 사용하며, Docker Client는 둘 이상의 Docker Daemon과 통신 할 수 있다. Docker Registry Docker Registry는 Docker Image를 저장한다. Docker Hub는 누구나 사용할 수있는 Public Registry이며, Docker는 기본적으로 Docker Hub에서 Image를 찾아 Container를 구성하도록 되어 있다. 예를 들어, docker pull을 사용하여 Image를 Registry에서 Local로 내려받을 수 있으며, docker push를 통해 Local의 Image를 Registry에 저장할 수도 있다. Docker Registry는 개개인이 구성할 수도 있으며, Docker의 Enterprise Edition에서 제공되는 Docker Trusted Registry이 포함된 Docker Datacenter를 사용할 수도 있다.Client-Server Model Docker는 서비스의 요청자(Docker Client) 와 제공자(Docker Server) 간의 작업이 분리되어 동작하는 Client-Server Model로 되어있으며, Docker Client는 REST API를 사용하여 Docker Server를 제어한다. Docker Client: docker CLI Docker Server: docker daemon Docker REST API Docker Server(docker daemon)는 Docker Client로부터 받은 요청에 따라, 다음의 Docker Object들을 생성하고 관리한다. Image Container Network Data Volumes Docker Client는 Docker Daemon과 UNIX Socket 또는 REST API를 사용하여 통신을 하며, Docker Daemon이 Container를 구축, 실행 및 배포할 수 있도록 한다. Docker Client와 Daemon은 동일한 시스템에서 실행될 수도 있고, Docker Client를 원격으로 Docker Daemon에 연결하여 사용할 수도 있다.REST API(Representational State Transfer API)* API(Application Programming Interface)란? - 데이터와 기능의 집합을 제공하여 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환가능 하도록 하는것* REST API정의 - REST 기반으로 서비스 API를 구현한 것 - 최근 OpenAPI(누구나 사용할 수 있도록 공개된 API: 구글 맵, 공공 데이터 등), 마이크로 서비스(하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처) 등을 제공하는 업체 대부분은 REST API를 제공한다.REST API의 특징- 사내 시스템들도 REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다.- REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.- 즉, REST API를 제작하면 델파이 클라이언트 뿐 아니라, 자바, C#, 웹 등을 이용해 클라이언트를 제작할 수 있다.Registry Image가 저장된 장소로 Private 또는 Public regsitry가 존재한다. Docker Hub 는 Docker, Inc에서 제공하는 Public registry다. Docker Hub는 GitHub와 같은 기능을 제공하고, 다른 사용자의 Image도 사용 가능하다. Docker Image &amp; Container 이미지는 서비스 운영에 필요한 서버프로그램, 소스코드, 컴파일된 실행 파일을 묶은 형태이다. 저장소에 올리고 받는건 이미지이다.(Docker-hub) 이미지로 여러개의 컨테이너를 만들 수 있다. 운영체제로 치면 이미지는 실행파일이고 컨테이너는 프로세스이다. 인프라 환경을 컨테이너로 관리한다. 애플리케이션의 실행에 필요한 모든 파일 및 디렉토리들을 컨테이너로서 모아버린 것이다.Image Image는 Docker Container를 생성하기 위한 읽기 전용 Template이다. Image들은 다른 Image 기반 위에 Customizing이 추가되어 만들어질 수 있으며, 이렇게 만들어진 Image는 Docker Registry에 Push한 뒤 사용할 수 있다.Container Container는 Docker API 사용하여 생성, 시작, 중지, 이동 또는 삭제 할 수 있는 Image의 실행가능한 Instance를 나타낸다. Container를 하나 이상의 Network에 연결하거나, 저장 장치로 묶을 수 있으며, 현재 상태를 바탕으로 새로운 Image를 생성할 수도 있다.Service Service를 사용하면, 여러 개의 Docker Daemon들로 이루어진 영역 내에서 Container들을 확장(Scaling)시킬 수 있다. Service는 ‘특정 시간동안 사용 가능한 Service의 Replica 개수’와 같은 상태 정보들을 직접 정의하여 사용할 수 있다. 기본적으로 Service는 Docker Daemon들 간의 Load Balancing을 제공하고 있기 때문에, 사용자 관점에서는 단일 Application으로 보인다.Docker의 Image처리 방식(레이어 저장 방식) 도커 이미지는 컨테이너를 실행하기 위한 모든 정보를 가지고 있기 때문에 용량이 수백MB에 이른다. 처음 이미지를 다운 받을 땐 크게 부담이 안되지만 기존 이미지에 파일 하나 추가했다고 수백메가를 다시 다운받는다면 매우 비효율적이다. 도커는 이런 문제를 해결하기 위해 레이어라는 개념을 사용하고 유니온 파일 시스템을 이용하여 여러개의 레이어를 하나의 파일시스템으로 사용할 수 있게 해준다. 이미지는 여러개의 읽기 전용(read only) 레이어로 구성되고 파일이 추가되거나 수정되면 새로운 레이어가 생성된다. ubuntu 이미지가 A + B + C의 집합이라면, ubuntu 이미지를 베이스로 만든 nginx 이미지는 A + B + C + nginx가 된다. web app 이미지를 nginx 이미지 기반으로 만들었다면 예상대로 A + B + C + nginx + source 레이어로 구성된다. web app 소스를 수정하면 A, B, C, nginx 레이어를 제외한 새로운 source(v2) 레이어만 다운받으면 되기 때문에 굉장히 효율적으로 이미지를 관리할 수 있다." }, { "title": "오라클 프로시저(Procedure) 생성 및 실행", "url": "/posts/PL_SQL_Procedure/", "categories": "PL/SQL, Procedure", "tags": "PL/SQL", "date": "2022-03-25 11:00:00 +0900", "snippet": "프로시저란? 자주 사용하는 SQL을 프로시저로 만든 뒤, 필요할 때마다 호출합니다. 작업의 효율성을 늘릴 수 있습니다. 함수(Function)와의 차이점 함수(Function): 특정 연산을 수행한 뒤, 결과 값을 반환한다. 프로시저(Procedure): 특정 로직을 처리하고 결과 값을 반환하지 않습니다. 프로시저 생성 CREATE OR REPLACE PROCEDURE TEST_PROC( P_MASK_ID IN VARCHAR2, P_POD_ID IN VARCHAR2, P_DEFECT_COUNT IN NUMBER)BEGININSERT INTO INSPECTION (MASK_ID, POD_ID, DEFECT_COUNT)VALUES (P_MASK_ID, P_POD_ID, P_DEFECT_COUNT);COMMIT;END TEST_PROC프로시저 실행EXEC TEST_PROC('S10G540A', 'RDE', 80);프로시저 결과 MASK_ID POD_ID DEFECT_COUNT S10G540A RDE 80 " }, { "title": "NoSQL 정의", "url": "/posts/NoSQL/", "categories": "NoSQL, 정의", "tags": "NoSQL", "date": "2022-03-25 11:00:00 +0900", "snippet": "NoSQL이란? NoSQL은 비관계형 데이터베이스를 지칭한다. 관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는데 특화되었으며, 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소이다. 기존 RDBMS 형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미하며, 관계형 데이터베이스의 한계를 극복하기 위한 데이터 저장소의 새로운 형태이다." }, { "title": "6. Docker Compose", "url": "/posts/Chap0-6.DockerCompose-Command/", "categories": "Docker, Chapter 0(명령어 정리)", "tags": "Docker Command", "date": "2022-03-24 11:00:00 +0900", "snippet": "## 컨테이너 생성 및 실행(up)&gt; docker-compose up&gt; docker-compose up -d&gt; docker-compose up --scale service1=2 --scale service2=3## 여러 컨테이너 확인(ps/logs)&gt; docker-compose ps&gt; docker-compose logs## 생성할 컨테이너 개수(scale)&gt; docker-compose scale service1=3## 컨테이너에서 명령 실행(run)&gt; docker-compose run service1 /bin/bash## 여러 컨테이너 시작/정지/재시작(start/stop/restart)&gt; docker-compose start&gt; docker-compose stop&gt; docker-compose stop service1&gt; docker-compose restart## 여러 컨테이너 일시 정지/재개(pause/unpase)&gt; docker-compose pause&gt; docker-compose unpause## 서비스의 구성 확인(port/config)&gt; docker-compose port webserver 80&gt; docker-compose config## 여러 컨테이너 강제 정지/삭제(kill/rm)&gt; docker-compose kill&gt; docker-compose rm&gt; docker-compose rm -f## 여러 리스소의 일괄삭제(down)&gt; docker-compose down --rmi all--------------------------------------------# web, logserver, redis, db 서비스를 작성한다.version: '3'services: web: # dockerfile을 빌드해 이미지를 생성한다. build: . ports: - \"5000:5000\" # logserver와 연결 links: - logserver:log01# logserver 컨테이너를 시작하기 전에 db 컨테이너와 redis 컨테이너를 시작 logserver: image: httpd depends_on: - db - redis redis: image: redis db: image: postgres # 컨테이너 정보 설정 labels: - \"com.example.department=Finance\" # 볼륨 설정(호스트:컨테이너) volumes: - ./docker/data:/var/lib/postgresql/data # 환경 변수 지정 environment: - POSTGRES_DB=sampledb - POSTGRES_USER=sampleuser - POSTGRES_PASSWORD=samplesecret - POSTGRES_INITDB_ARGS=--encoding=UTF-8" }, { "title": "5. Docker File", "url": "/posts/Chap0-5.DockerFile-Command/", "categories": "Docker, Chapter 0(명령어 정리)", "tags": "Docker Command", "date": "2022-03-24 11:00:00 +0900", "snippet": "# 베이스 이미지 설정FROM ubuntu# RUN 명령의 실행RUN apt-get -y update &amp;&amp; apt-get -y upgradeRUN apt-get -y install nginx# 포트 지정EXPOSE 80# 웹 콘텐츠 배치ONBUILD ADD index.html /var/www/html# 헬스 체크HEALTHCHECK --interval=5m --timeout=3s CMD curl -f http://localhost/ || exit 1# 서버 실행CMD [\"nginx\", \"-g\", \"daemon off;\"]# 환경 변수 설정ENV myNickName miya# 작업 디젝토리 지정ENV DIRPATH /firstENV DIRNAME secondWORKDIR $DIRPATH/$DIRNAMERUN [\"pwd\"]# 사용자 지정RUN [\"adduser\", \"jihye\"]RUN [\"whoami\"]USER jihyeRUN [\"whoami\"]# 라벨 설정LABEL version=\"1.0\"# 포트 지정EXPOSE 80# 변수의 정의ARG YOURNAME=\"jihye\"RUN echo $YOURNAME# 기본 쉘 지정SHELL [\"/bin/bash\", \"-C\"]## 파일 및 디렉토리 추가ADD host.html /docker_dir/## 파일 복사COPY host.html /docker_dir/## 볼륨 마운트VOLUME /tmp/share" }, { "title": "4. Docker Network & Volumn", "url": "/posts/Chap0-4.DockerNetAndVolumn-Command/", "categories": "Docker, Chapter 0(명령어 정리)", "tags": "Docker Command", "date": "2022-03-24 11:00:00 +0900", "snippet": "## 컨테이너 환경변수 설정&gt; docker container run -d -e MYSQL_ROOT_PASSWORD=1234 --name db1 mysql## 네트워크 목록 표시&gt; docker network ls## 네트워크 상세 정보 확인&gt; docker network inspect bridge## 네트워크 생성&gt; docker network create --driver=bridge d-net&gt; docker network create --subnet 192.168.0.0/24 --gateway 192.168.0.254 customnet## 네트워크 연결&gt; docker container run -it --name a1 alpine&gt; docker attach a1/ # ifconfig&gt; docker network connect customnet a1&gt; docker attach a1/ # ifconfig&gt; docker container run -it --net customnet --name a1 alpine&gt; docker network disconnect customnet a1## 네트워크 삭제&gt; docker network rm d-net## 컨테이너 링크&gt; docker run -itd --name a1 alpine&gt; docker run -itd --name a2 --link a1 alpine&gt; docker attach a2/ # ping -c1 a1&gt; docker attach a1/ # ping -c1 a2## 외부에서 컨테이너 접속&gt; docker container run -d -p 80:80 --name web2 httpd&gt; docker container ps&gt; curl localhost" }, { "title": "2. Docker Container", "url": "/posts/Chap0-2.DockerContainer-Command/", "categories": "Docker, Chapter 0(명령어 정리)", "tags": "Docker Command", "date": "2022-03-24 11:00:00 +0900", "snippet": "## 컨테이너 생성&gt; docker container create -it --name c1 centos## 컨테이너 시작&gt; docker container start c1## 컨테이너 정지&gt; docker container stop c1&gt; docker container pause c2## 컨테이너 생성 및 시작&gt; docker container run -it centos&gt; docker container run -it --name c2 centos## 컨테이너 재시작&gt; docker contaienr restart c1## 컨테이너 삭제&gt; docker container rm c1 c2&gt; docker container unpause c2## 컨테이너 확인&gt; docker ps&gt; docker container ls&gt; docker container inspect c8f## 컨테이너 접근&gt; docker container attach webserver## 컨테이너에서 어플리케이션 실행&gt; docker container exec -it webserver /bin/echo \"Hello world\"## 컨테이너에서 실행 중인 프로세스 확인&gt; docker container top webserver## 컨테이너 이름 변경&gt; docker container rename webserver s1## 컨테이너 로그 확인&gt; docker container logs s1## 컨테이너 차분 확인&gt; docker contaienr diff s1" }, { "title": "1. Docker Image", "url": "/posts/Chap0-1.DockerImage-Command/", "categories": "Docker, Chapter 0(명령어 정리)", "tags": "Docker Command", "date": "2022-03-24 11:00:00 +0900", "snippet": "## 이미지 검색&gt; docker search hello-world## 즐겨찾기 수가 1000이상의 이미지 검색&gt; docker search centos -s 1000## 이미지 다운로드&gt; docker image pull centos:7## 이미지 목록 표시&gt; docker image ls&gt; docker images## 이미지 상세 정보 확인&gt; docker iamge inspect centos:7## 이미지 태그 설정&gt; docker image tag nginx mirero/webserver:1.0## 이미지 삭제&gt; docker rmi hello-world&gt; docker image rm hello-world&gt; docker image rm -f 9f&gt; docker image prune## 이미지 업로드&gt; docker login&gt; docker tag centos:latest jh0105123/centos:v2&gt; docker image push jh0105123/centos:v2&gt; docker logout## 컨테이너로부터 이미지 생성&gt; docker container run -it --name c1 centos&gt; docker container commit c1 centos:hello## 컨테이너를 tar 파일로 출력&gt; docker attach c1# echo \"This is export test\" &gt; export.txt# cat export.txt&gt; docker container export -o ./testexport.tar c1&gt; tar tf testexport.tar | findstr export.txt## 아카이브 파일로 이미지 만들기&gt; docker image import testexport.tar export:test## 이미지 저장&gt; docker image save -o imgarc.tar centos&gt; attrib imgarc.tar## 이미지 불러오기&gt; docker image load -i imgarc.tar## 컨테이너 파일 복사&gt; docker container cp dockercp.txt c1:/&gt; docker container exec -it c1 cat /dockercp.txt## 컨테이너 파일 변경 확인&gt; docker container diff c1" } ]
